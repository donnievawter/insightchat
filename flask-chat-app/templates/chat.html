<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>InsightChat - AI Chat with RAG</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>

<body>
    <div class="chat-container">
        <div class="chat-header">
            <h1>InsightChat</h1>
            <form method="POST" action="{{ url_for('chat.reset') }}" style="display: inline;">
                <button type="submit" class="reset-btn">Reset Chat</button>
            </form>
        </div>

        <div class="chat-settings">
            <div class="settings-row">
                <label for="model">Model:</label>
                <select name="model" id="model" form="chat-form">
                    {% for model_info in available_models %}
                    <option value="{{ model_info.name }}" {{ 'selected' if model==model_info.name else '' }}>
                        {{ model_info.name }}
                        {% if model_info.parameter_size %}({{ model_info.parameter_size }}){% endif %}
                    </option>
                    {% endfor %}
                </select>

                <label for="use_repo_docs">
                    <input type="checkbox" name="use_repo_docs" id="use_repo_docs" form="chat-form" {{ 'checked' if
                        use_repo_docs else '' }}>
                    Use RAG Context
                </label>
                
                {% if RAG_API_URL %}
                <button type="button" class="browse-docs-btn" onclick="openDocumentBrowser()" title="Browse and load documents from RAG system">
                    üìö Browse Documents
                </button>
                <button type="button" class="upload-file-btn" onclick="openFileUpload()" title="Upload file to RAG system">
                    üì§ Upload File
                </button>
                {% endif %}
            </div>
        </div>

        {% if error %}
        <div class="error-message">{{ error }}</div>
        {% endif %}

        <div class="chat-messages" id="chat-messages">
            {% for message in message_history %}
            <div class="message {{ message.role }}">
                <div class="message-header">
                    <span class="message-role">{{ message.role.title() }}</span>
                    <div class="message-header-actions">
                        {% if message.role == 'assistant' %}
                        <button class="download-markdown-btn" onclick="downloadMarkdownResponse('{{ loop.index0 }}')" title="Download as Markdown">
                            üíæ MD
                        </button>
                        {% endif %}
                        {% if message.role == 'assistant' and message.get('sources') %}
                    <button class="toggle-chunks-btn" onclick="toggleChunks('{{ loop.index }}')">
                        <span id="chunks-icon-{{ loop.index }}">üìÑ</span>
                        <span id="chunks-text-{{ loop.index }}">Show Sources ({{ message.sources|length }})</span>
                    </button>
                    {% elif message.role == 'assistant' and message.get('rag_chunks') %}
                    <button class="toggle-chunks-btn" onclick="toggleChunks('{{ loop.index }}')">
                        <span id="chunks-icon-{{ loop.index }}">ÔøΩ</span>
                        <span id="chunks-text-{{ loop.index }}">Show Sources ({{ message.rag_chunks|length }})</span>
                    </button>
                    {% endif %}
                    </div>
                </div>
                <div class="message-content">{{ message.content | safe }}</div>

                {% if message.role == 'assistant' and message.get('sources') %}
                <div class="sources-section" id="chunks-{{ loop.index }}" style="display: none;">
                    <div class="sources-header">
                        <h4>Available Sources</h4>
                        <p class="sources-help">Click "Load" to expand context with full content from that source</p>
                    </div>
                    {% set outer_loop = loop %}
                    {% for source in message.sources %}
                    <div class="source-item">
                        <div class="source-header">
                            <span class="source-filename">{{ source.filename }}</span>
                            <span class="source-path">{{ source.path }}</span>
                            {% if source.is_csv %}
                            <span class="source-type csv-badge">CSV</span>
                            {% else %}
                            <span class="source-type">{{ source.file_type.upper() }}</span>
                            {% endif %}
                        </div>
                        <div class="source-actions">
                            <button class="load-source-btn" data-source-path="{{ source.path }}"
                                data-message-index="{{ outer_loop.index0 }}" onclick="loadSourceContext(this)">
                                <span class="load-icon">üì•</span>
                                Load
                                {% if source.is_csv %}(Full CSV){% else %}(All Chunks){% endif %}
                            </button>
                            <button class="view-doc-btn" data-source="{{ source.path }}">
                                View Document
                            </button>
                        </div>
                    </div>
                    {% endfor %}
                </div>
                {% elif message.role == 'assistant' and message.get('rag_chunks') %}
                <div class="rag-chunks" id="chunks-{{ loop.index }}" style="display: none;">
                    <div class="chunks-header">
                        <h4>Retrieved Context Sources</h4>
                    </div>
                    {% set outer_loop = loop %}
                    {% for chunk in message.rag_chunks %}
                    <div class="chunk-item">
                        <div class="chunk-header">
                            <span class="chunk-source">{{ chunk.metadata.get('source', 'Unknown Source') }}</span>
                            {% if chunk.metadata.get('page') %}
                            <span class="chunk-page">Page {{ chunk.metadata.page }}</span>
                            {% endif %}
                            <button class="view-doc-btn" data-source="{{ chunk.metadata.get('source', '') }}"
                                data-start-index="{{ chunk.get('start_index', 0) }}">
                                View Document
                            </button>
                        </div>
                        <div class="chunk-content">
                            <p>{{ chunk.content[:200] }}{% if chunk.content|length > 200 %}...{% endif %}</p>
                        </div>
                        <div class="chunk-actions">
                            <button class="expand-chunk-btn"
                                onclick="toggleChunkExpansion('msg{{ outer_loop.index }}_chunk{{ loop.index0 }}')">
                                <span id="chunk-expand-msg{{ outer_loop.index }}_chunk{{ loop.index0 }}">Show
                                    More</span>
                            </button>
                            <div class="chunk-full-content"
                                id="chunk-full-msg{{ outer_loop.index }}_chunk{{ loop.index0 }}" style="display: none;">
                                <p>{{ chunk.content }}</p>
                            </div>
                        </div>
                    </div>
                    {% endfor %}
                </div>
                {% endif %}


            </div>
            {% endfor %}
        </div>

        <form id="chat-form" method="POST" action="{{ url_for('chat.chat') }}">
            <div class="input-row">
                <div class="input-with-audio">
                    <input type="text" name="prompt" id="prompt-input" placeholder="Type your message..." required>
                    <div class="audio-controls">
                        <button type="button" id="recordBtn" class="audio-btn" title="Start Recording">
                            üé§
                        </button>
                        <button type="button" id="stopBtn" class="audio-btn hidden" disabled title="Stop Recording">
                            ‚èπÔ∏è
                        </button>
                    </div>
                </div>
                <button type="submit">Send</button>
            </div>
            <div id="recording-status" class="recording-status hidden"></div>
        </form>
        
        <!-- Hidden form fields for loaded context -->
        <input type="hidden" name="loaded_context" id="loaded-context" form="chat-form" value="">
        <input type="hidden" name="loaded_source_meta" id="loaded-source-meta" form="chat-form" value="">
    </div>
    
    <!-- Document Browser Modal -->
    <div id="document-browser-modal" class="modal" style="display: none;">
        <div class="modal-content document-browser">
            <div class="modal-header">
                <h2>Browse RAG Documents</h2>
                <button class="close-btn" onclick="closeDocumentBrowser()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="search-box">
                    <input type="text" id="doc-search" placeholder="Search documents by name..." oninput="filterDocuments()">
                </div>
                <div id="document-list" class="document-list">
                    <div class="loading-message">Loading documents...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Audio recording state
        let mediaRecorder;
        let audioChunks = [];
        let startTime;
        let timerInterval;

        document.addEventListener('DOMContentLoaded', function () {
            // Auto-scroll to bottom of messages
            const chatMessages = document.getElementById('chat-messages');
            if (chatMessages) {
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }

            // Focus on input field
            const promptInput = document.querySelector('input[name="prompt"]');
            if (promptInput) {
                promptInput.focus();
            }

            // Initialize audio recording buttons
            initializeAudioRecording();

            // Render markdown in assistant messages
            renderMarkdownInMessages();

            // Handle form submission to disable/enable send button
            const chatForm = document.getElementById('chat-form');
            const sendButton = chatForm ? chatForm.querySelector('button[type="submit"]') : null;

            if (chatForm && sendButton) {
                const originalButtonText = sendButton.textContent;

                chatForm.addEventListener('submit', function (e) {
                    const message = promptInput.value.trim();
                    if (!message) {
                        e.preventDefault();
                        return;
                    }

                    // Disable button and show loading state
                    sendButton.disabled = true;
                    sendButton.textContent = 'Sending...';
                });
            }

            // Handle view document buttons
            document.addEventListener('click', function (e) {
                if (e.target.classList.contains('view-doc-btn')) {
                    const source = e.target.getAttribute('data-source');
                    const startIndex = parseInt(e.target.getAttribute('data-start-index') || '0');
                    viewDocument(source, startIndex);
                }
            });
        });

        // Audio Recording Functions
        function initializeAudioRecording() {
            const recordBtn = document.getElementById('recordBtn');
            const stopBtn = document.getElementById('stopBtn');

            if (recordBtn) {
                recordBtn.addEventListener('click', startRecording);
            }
            if (stopBtn) {
                stopBtn.addEventListener('click', stopRecording);
            }
        }

        function updateRecordingStatus(message, type = 'info') {
            const status = document.getElementById('recording-status');
            if (status) {
                status.textContent = message;
                status.className = `recording-status ${type}`;
                status.classList.remove('hidden');
            }
        }

        function hideRecordingStatus() {
            const status = document.getElementById('recording-status');
            if (status) {
                status.classList.add('hidden');
            }
        }

        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

                // Try different formats
                let mimeType = 'audio/ogg;codecs=opus';
                if (!MediaRecorder.isTypeSupported(mimeType)) {
                    mimeType = 'audio/mp4';
                }
                if (!MediaRecorder.isTypeSupported(mimeType)) {
                    mimeType = 'audio/webm;codecs=opus';
                }
                if (!MediaRecorder.isTypeSupported(mimeType)) {
                    mimeType = 'audio/webm';
                }

                mediaRecorder = new MediaRecorder(stream, { mimeType: mimeType });
                audioChunks = [];

                mediaRecorder.ondataavailable = (event) => {
                    audioChunks.push(event.data);
                };

                mediaRecorder.onstop = async () => {
                    let extension = '.webm';
                    if (mimeType.includes('ogg')) extension = '.ogg';
                    else if (mimeType.includes('mp4')) extension = '.m4a';

                    const audioBlob = new Blob(audioChunks, { type: mimeType });
                    await uploadAudio(audioBlob, extension);

                    // Stop all tracks
                    stream.getTracks().forEach(track => track.stop());
                };

                mediaRecorder.start();

                const recordBtn = document.getElementById('recordBtn');
                const stopBtn = document.getElementById('stopBtn');

                recordBtn.classList.add('recording');
                recordBtn.classList.add('hidden');
                stopBtn.classList.remove('hidden');
                stopBtn.disabled = false;

                updateRecordingStatus('üéôÔ∏è Recording... Click stop when done', 'processing');

            } catch (error) {
                console.error('Error accessing microphone:', error);
                updateRecordingStatus('‚ùå Error: Could not access microphone', 'error');
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                const stopBtn = document.getElementById('stopBtn');
                stopBtn.disabled = true;
                updateRecordingStatus('Processing audio...', 'processing');
            }
        }

        async function uploadAudio(audioBlob, extension) {
            try {
                const formData = new FormData();
                formData.append('file', audioBlob, `recording${extension}`);

                updateRecordingStatus('Transcribing audio...', 'processing');

                const response = await fetch('/transcribe', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Transcription failed');
                }

                const result = await response.json();

                // Update input with transcription
                const promptInput = document.getElementById('prompt-input');
                if (promptInput) {
                    promptInput.value = result.text;
                    promptInput.focus();
                }

                updateRecordingStatus('‚úÖ Transcription complete!', 'success');
                setTimeout(hideRecordingStatus, 3000);

            } catch (error) {
                console.error('Error uploading audio:', error);
                updateRecordingStatus(`‚ùå Error: ${error.message}`, 'error');
            } finally {
                // Reset recording UI
                const recordBtn = document.getElementById('recordBtn');
                const stopBtn = document.getElementById('stopBtn');

                recordBtn.classList.remove('recording');
                recordBtn.classList.remove('hidden');
                stopBtn.classList.add('hidden');
                stopBtn.disabled = true;
            }
        }

        // Toggle chunks display
        function toggleChunks(messageIndex) {
            const chunksDiv = document.getElementById('chunks-' + messageIndex);
            const icon = document.getElementById('chunks-icon-' + messageIndex);
            const text = document.getElementById('chunks-text-' + messageIndex);

            if (chunksDiv.style.display === 'none') {
                chunksDiv.style.display = 'block';
                icon.textContent = 'üìÇ';
                text.textContent = text.textContent.replace('Show', 'Hide');
            } else {
                chunksDiv.style.display = 'none';
                icon.textContent = 'üìÑ';
                text.textContent = text.textContent.replace('Hide', 'Show');
            }
        }

        // Toggle individual chunk expansion
        function toggleChunkExpansion(chunkIndex) {
            const fullContent = document.getElementById('chunk-full-' + chunkIndex);
            const expandBtn = document.getElementById('chunk-expand-' + chunkIndex);

            if (fullContent && expandBtn) {
                if (fullContent.style.display === 'none') {
                    fullContent.style.display = 'block';
                    expandBtn.textContent = 'Show Less';
                } else {
                    fullContent.style.display = 'none';
                    expandBtn.textContent = 'Show More';
                }
            }
        }

        // Render markdown in assistant messages
        function renderMarkdownInMessages() {
            const assistantMessages = document.querySelectorAll('.message.assistant .message-content');

            assistantMessages.forEach(messageContent => {
                // Skip if already processed
                if (messageContent.dataset.markdownProcessed === 'true') {
                    return;
                }

                const text = messageContent.textContent || messageContent.innerText;

                console.log('Checking message for markdown:', {
                    length: text.length,
                    preview: text.substring(0, 100),
                    innerHTML: messageContent.innerHTML.substring(0, 100)
                });

                // Check if this message looks like markdown
                if (looksLikeMarkdown(text)) {
                    console.log('Rendering message as markdown');
                    // Render as markdown
                    messageContent.innerHTML = '<div class="markdown-content">' + markdownToHtml(text) + '</div>';
                    messageContent.dataset.markdownProcessed = 'true';
                } else {
                    console.log('Message does not look like markdown');
                }
            });
        }

        // View document in modal
        function viewDocument(source, startIndex = 0) {
            // Create modal overlay
            const overlay = document.createElement('div');
            overlay.className = 'document-viewer-overlay';
            overlay.onclick = function (e) {
                if (e.target === overlay) {
                    closeDocumentViewer();
                }
            };

            // Create document viewer
            const viewer = document.createElement('div');
            viewer.className = 'document-viewer';

            // Create header
            const header = document.createElement('div');
            header.className = 'document-viewer-header';
            header.innerHTML = `
                <h3>${source}</h3>
                <button class="document-viewer-close" onclick="closeDocumentViewer()">Close</button>
            `;

            // Create content area
            const content = document.createElement('div');
            content.className = 'document-viewer-content';
            content.innerHTML = '<div style="text-align: center; padding: 40px; color: #7d8590;">Loading document...</div>';

            viewer.appendChild(header);
            viewer.appendChild(content);
            overlay.appendChild(viewer);
            document.body.appendChild(overlay);

            // Fetch document content
            fetchDocumentContent(source, startIndex, content);
        }

        // Close document viewer
        function closeDocumentViewer() {
            const overlay = document.querySelector('.document-viewer-overlay');
            if (overlay) {
                overlay.remove();
            }
        }

        // Fetch and display document content
        function fetchDocumentContent(source, startIndex, contentElement) {
            // Determine file type from extension
            const fileExtension = source.split('.').pop().toLowerCase();
            const imageExtensions = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'svg', 'bmp'];
            const textExtensions = ['txt', 'md', 'py', 'js', 'html', 'css', 'json', 'xml', 'yaml', 'yml', 'sh', 'conf', 'log'];
            const pdfExtensions = ['pdf'];
            const csvExtensions = ['csv', 'tsv'];
            const docxExtensions = ['docx', 'doc'];
            const emailExtensions = ['eml', 'emlx'];
            const audioExtensions = ['wav', 'mp3', 'm4a', 'flac', 'ogg'];



            if (imageExtensions.includes(fileExtension)) {
                // Display image
                displayImageDocument(source, contentElement);
            } else if (pdfExtensions.includes(fileExtension)) {
                // Display PDF
                displayPdfDocument(source, contentElement);
            } else if (csvExtensions.includes(fileExtension)) {
                // Display CSV as table
                displayCsvDocument(source, contentElement);
            } else if (docxExtensions.includes(fileExtension)) {
                // Display DOCX document
                displayDocxDocument(source, contentElement);
            } else if (audioExtensions.includes(fileExtension)) {
                // Display audio player
                displayAudioDocument(source, contentElement);
            } else if (textExtensions.includes(fileExtension)) {
                // Display as text
                displayTextDocument(source, startIndex, contentElement);
            } else if (emailExtensions.includes(fileExtension)) {
                // Display email
                displayEmailDocument(source, contentElement);
            } else {
                // Try to display as text first, fallback to binary info
                displayTextDocument(source, startIndex, contentElement, true);
            }
        }

        // Display image documents
        function displayImageDocument(source, contentElement) {
            contentElement.innerHTML = `
                <div style="text-align: center; padding: 20px;">
                    <div style="margin-bottom: 20px; color: #58a6ff;">
                        <strong>üì∑ Image Document</strong><br>
                        <small>Source: ${escapeHtml(source)}</small>
                    </div>
                    <div style="max-width: 100%; overflow: auto;">
                        <img src="{{ url_for('chat.get_document') }}?source=${encodeURIComponent(source)}" 
                             alt="${escapeHtml(source)}" 
                             style="max-width: 100%; height: auto; border: 1px solid #30363d; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.3);"
                             onload="this.style.display='block'" 
                             onerror="this.style.display='none'; this.nextElementSibling.style.display='block'">
                        <div style="display: none; padding: 20px; background: #2d1b20; border: 1px solid #da3633; border-radius: 8px; color: #f97583;">
                            <strong>Error loading image</strong><br>
                            The image could not be displayed. It may be corrupted or in an unsupported format.
                        </div>
                    </div>
                    <div style="margin-top: 20px; font-size: 0.9em; color: #7d8590;">
                        This image was referenced in the RAG context. 
                        <br>For text content, check if there are associated description files.
                    </div>
                </div>
            `;
        }

        // Display audio documents
        function displayAudioDocument(source, contentElement) {
            const fileName = decodeURIComponent(source.split('/').pop());
            const fileExtension = source.split('.').pop().toLowerCase();

            contentElement.innerHTML = `
                <div class="audio-document-container">
                    <div class="audio-header">
                        <div class="audio-title">
                            <span class="audio-icon">üéµ</span>
                            <div class="audio-info">
                                <div class="audio-name">${escapeHtml(fileName)}</div>
                                <div class="audio-source">Source: ${escapeHtml(decodeURIComponent(source))}</div>
                            </div>
                        </div>
                        <div class="audio-actions">
                            <button onclick="downloadAudio('${encodeURIComponent(source)}')" class="audio-btn audio-download-btn" title="Download Audio">
                                <span class="audio-btn-icon">‚¨á</span>
                            </button>
                        </div>
                    </div>
                    <div class="audio-player-wrapper">
                        <div class="audio-player-info">
                            <div class="audio-format-badge">${fileExtension.toUpperCase()}</div>
                            <div class="audio-description">Audio file from RAG context</div>
                        </div>
                        <audio controls class="audio-player" preload="metadata">
                            <source src="{{ url_for('chat.get_document') }}?source=${encodeURIComponent(source)}" type="audio/${fileExtension === 'mp3' ? 'mpeg' : fileExtension}">
                            Your browser does not support the audio element.
                        </audio>
                        <div class="audio-error" style="display: none;">
                            <div class="audio-error-icon">‚ö†Ô∏è</div>
                            <div class="audio-error-text">
                                <strong>Audio playback unavailable</strong><br>
                                <span>Your browser doesn't support this audio format</span>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // Handle audio loading errors
            const audioElement = contentElement.querySelector('.audio-player');
            if (audioElement) {
                audioElement.addEventListener('error', function () {
                    contentElement.querySelector('.audio-player-wrapper').style.display = 'none';
                    contentElement.querySelector('.audio-error').style.display = 'flex';
                });
            }
        }

        // Download audio file
        function downloadAudio(source) {
            const link = document.createElement('a');
            link.href = '{{ url_for("chat.get_document") }}?source=' + encodeURIComponent(source);
            link.download = decodeURIComponent(source.split('/').pop());
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Display PDF documents
        function displayPdfDocument(source, contentElement) {
            contentElement.innerHTML = `
                <div class="pdf-document-container">
                    <div class="pdf-header">
                        <div class="pdf-title">
                            <span class="pdf-icon">üìÑ</span>
                            <div class="pdf-info">
                                <div class="pdf-name">${escapeHtml(decodeURIComponent(source.split('/').pop()))}</div>
                                <div class="pdf-source">Source: ${escapeHtml(decodeURIComponent(source))}</div>
                            </div>
                        </div>
                        <div class="pdf-actions">
                            <button onclick="downloadPdf('${encodeURIComponent(source)}')" class="pdf-btn pdf-download-btn" title="Download PDF">
                                <span class="pdf-btn-icon">‚¨á</span>
                            </button>
                            <button onclick="openPdfInNewTab('${encodeURIComponent(source)}')" class="pdf-btn pdf-newtab-btn" title="Open in New Tab">
                                <span class="pdf-btn-icon">‚Üó</span>
                            </button>
                        </div>
                    </div>
                    <div class="pdf-viewer-frame">
                        <iframe id="pdf-viewer-${Date.now()}" 
                                src="{{ url_for('chat.get_document') }}?source=${encodeURIComponent(source)}" 
                                class="pdf-iframe"
                                onload="this.style.display='block'; this.nextElementSibling.style.display='none';"
                                onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                        </iframe>
                        <div class="pdf-error-fallback" style="display: none;">
                            <div class="pdf-error-content">
                                <div class="pdf-error-icon">‚ö†Ô∏è</div>
                                <div class="pdf-error-text">
                                    <strong>PDF Preview Unavailable</strong><br>
                                    <span>Your browser doesn't support inline PDF viewing</span>
                                </div>
                                <button onclick="downloadPdf('${encodeURIComponent(source)}')" class="pdf-error-btn">
                                    Download PDF
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        // Display CSV documents as tables
        function displayCsvDocument(source, contentElement) {
            contentElement.innerHTML = `
                <div class="csv-document-container">
                    <div class="csv-header">
                        <div class="csv-title">
                            <span class="csv-icon">üìä</span>
                            <div class="csv-info">
                                <div class="csv-name">${escapeHtml(decodeURIComponent(source.split('/').pop()))}</div>
                                <div class="csv-source">Source: ${escapeHtml(decodeURIComponent(source))}</div>
                            </div>
                        </div>
                        <div class="csv-actions">
                            <button onclick="downloadCsv('${encodeURIComponent(source)}')" class="csv-btn csv-download-btn" title="Download CSV">
                                <span class="csv-btn-icon">‚¨á</span>
                            </button>
                            <button onclick="openCsvInNewTab('${encodeURIComponent(source)}')" class="csv-btn csv-newtab-btn" title="Open Raw CSV">
                                <span class="csv-btn-icon">‚Üó</span>
                            </button>
                        </div>
                    </div>
                    <div class="csv-content-area">
                        <div class="csv-loading">Loading CSV data...</div>
                    </div>
                </div>
            `;

            // Fetch and parse CSV data
            fetch('{{ url_for("chat.get_document") }}?source=' + encodeURIComponent(source))
                .then(response => {
                    if (!response.ok) {
                        throw new Error('CSV file not found or not accessible');
                    }
                    return response.text();
                })
                .then(csvData => {
                    const csvContentArea = contentElement.querySelector('.csv-content-area');
                    const tableHtml = parseCsvToTable(csvData, source);
                    csvContentArea.innerHTML = tableHtml;
                })
                .catch(error => {
                    const csvContentArea = contentElement.querySelector('.csv-content-area');
                    csvContentArea.innerHTML = `
                        <div class="csv-error">
                            <div class="csv-error-icon">‚ö†Ô∏è</div>
                            <div class="csv-error-text">
                                <strong>Error loading CSV:</strong><br>
                                ${error.message}
                            </div>
                        </div>
                    `;
                });
        }

        // Parse CSV data and convert to HTML table
        function parseCsvToTable(csvData, source) {
            const lines = csvData.trim().split('\n');
            if (lines.length === 0) {
                return '<div class="csv-error">Empty CSV file</div>';
            }

            // Detect delimiter - check for common separators
            const firstLine = lines[0];
            let delimiter = ',';
            if (source.toLowerCase().endsWith('.tsv') || firstLine.includes('\t')) {
                delimiter = '\t';
            } else if (firstLine.split(';').length > firstLine.split(',').length) {
                delimiter = ';';
            }

            // Parse CSV rows
            const rows = lines.map(line => parseCsvLine(line, delimiter));

            if (rows.length === 0) {
                return '<div class="csv-error">No data found in CSV</div>';
            }

            // Build HTML table
            let tableHtml = `
                <div class="csv-info-bar">
                    <span class="csv-stats">${rows.length - 1} rows √ó ${rows[0]?.length || 0} columns</span>
                    <span class="csv-delimiter">Delimiter: ${delimiter === '\t' ? 'Tab' : delimiter}</span>
                </div>
                <div class="csv-table-wrapper">
                    <table class="csv-table">
            `;

            // Add header row (assume first row is headers)
            if (rows[0]) {
                tableHtml += '<thead><tr>';
                rows[0].forEach(cell => {
                    tableHtml += `<th>${escapeHtml(cell)}</th>`;
                });
                tableHtml += '</tr></thead>';
            }

            // Add data rows
            tableHtml += '<tbody>';
            const dataRows = rows.slice(1); // Skip header row
            const maxRows = 1000; // Limit for performance
            const displayRows = dataRows.slice(0, maxRows);

            displayRows.forEach(row => {
                tableHtml += '<tr>';
                row.forEach(cell => {
                    tableHtml += `<td>${escapeHtml(cell)}</td>`;
                });
                tableHtml += '</tr>';
            });

            if (dataRows.length > maxRows) {
                tableHtml += `
                    <tr class="csv-truncated-notice">
                        <td colspan="${rows[0]?.length || 1}">
                            <em>... ${dataRows.length - maxRows} more rows (showing first ${maxRows} rows)</em>
                        </td>
                    </tr>
                `;
            }

            tableHtml += '</tbody></table></div>';
            return tableHtml;
        }

        // Simple CSV line parser (handles quoted fields)
        function parseCsvLine(line, delimiter = ',') {
            const result = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];

                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === delimiter && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }

            result.push(current.trim());
            return result;
        }

        // CSV utility functions
        function downloadCsv(source) {
            const link = document.createElement('a');
            link.href = '{{ url_for("chat.get_document") }}?source=' + encodeURIComponent(source);
            link.download = decodeURIComponent(source.split('/').pop());
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function openCsvInNewTab(source) {
            // Fetch the CSV content and display in new tab
            fetch('{{ url_for("chat.get_document") }}?source=' + encodeURIComponent(source))
                .then(response => {
                    if (!response.ok) {
                        throw new Error('CSV file not accessible');
                    }
                    return response.text();
                })
                .then(csvContent => {
                    // Create a new window and write HTML content to display the CSV
                    const newWindow = window.open('', '_blank');
                    if (newWindow) {
                        const fileName = decodeURIComponent(source.split('/').pop());
                        const tableHtml = parseCsvToTable(csvContent, source);

                        newWindow.document.write(`
                            <!DOCTYPE html>
                            <html>
                            <head>
                                <title>${fileName}</title>
                                <style>
                                    body { 
                                        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                                        margin: 20px; 
                                        background: #0d1117; 
                                        color: #e6edf3;
                                    }
                                    h1 { 
                                        color: #58a6ff; 
                                        font-size: 1.5em;
                                        margin-bottom: 10px;
                                    }
                                    .info { 
                                        color: #7d8590; 
                                        margin-bottom: 20px; 
                                        font-size: 0.9em;
                                    }
                                    .csv-table-wrapper {
                                        border: 1px solid #21262d;
                                        border-radius: 6px;
                                        overflow: auto;
                                        max-height: 80vh;
                                    }
                                    .csv-table {
                                        width: 100%;
                                        border-collapse: collapse;
                                        font-size: 0.85em;
                                        background: #0d1117;
                                    }
                                    .csv-table th {
                                        background: #161b22;
                                        color: #58a6ff;
                                        font-weight: 600;
                                        padding: 8px 12px;
                                        text-align: left;
                                        border-bottom: 2px solid #30363d;
                                        border-right: 1px solid #21262d;
                                        position: sticky;
                                        top: 0;
                                        z-index: 100;
                                        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                                    }
                                    .csv-table th:last-child { border-right: none; }
                                    .csv-table td {
                                        padding: 6px 12px;
                                        border-bottom: 1px solid #21262d;
                                        border-right: 1px solid #21262d;
                                        color: #e6edf3;
                                        white-space: nowrap;
                                        overflow: hidden;
                                        text-overflow: ellipsis;
                                        max-width: 200px;
                                    }
                                    .csv-table td:last-child { border-right: none; }
                                    .csv-table tbody tr:hover { background: #161b22; }
                                    .csv-table tbody tr:nth-child(even) { background: rgba(22, 27, 34, 0.5); }
                                    .csv-table tbody tr:nth-child(even):hover { background: #161b22; }
                                    .csv-info-bar {
                                        display: flex;
                                        justify-content: space-between;
                                        padding: 8px 12px;
                                        background: #161b22;
                                        border-bottom: 1px solid #21262d;
                                        font-size: 0.8em;
                                        color: #7d8590;
                                    }
                                </style>
                            </head>
                            <body>
                                <h1>üìä ${fileName}</h1>
                                <div class="info">Source: ${decodeURIComponent(source)}</div>
                                ${tableHtml}
                            </body>
                            </html>
                        `);
                        newWindow.document.close();
                    } else {
                        alert('Popup blocked! Please allow popups for this site to view CSV files in new tabs.');
                    }
                })
                .catch(error => {
                    alert('Error opening CSV file: ' + error.message);
                });
        }

        // Display DOCX documents
        function displayDocxDocument(source, contentElement) {
            const fileName = decodeURIComponent(source.split('/').pop());
            contentElement.innerHTML = `
                <div class="docx-document-container">
                    <div class="docx-header">
                        <div class="docx-title">
                            <span class="docx-icon">üìÑ</span>
                            <div class="docx-info">
                                <div class="docx-name">${escapeHtml(fileName)}</div>
                                <div class="docx-source">Source: ${escapeHtml(decodeURIComponent(source))}</div>
                            </div>
                        </div>
                        <div class="docx-actions">
                            <button onclick="downloadDocx('${encodeURIComponent(source)}')" class="docx-btn" title="Download DOCX">
                                <span class="docx-btn-icon">‚¨á</span>
                            </button>
                        </div>
                    </div>
                    <div class="docx-content-area">
                        <div class="docx-loading">
                            <div class="docx-loading-spinner"></div>
                            <div>Extracting document content...</div>
                        </div>
                    </div>
                </div>
            `;

            // Request DOCX content extraction from backend
            fetch('{{ url_for("chat.get_document") }}?source=' + encodeURIComponent(source) + '&format=text')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('DOCX file not found or not accessible');
                    }
                    return response.text();
                })
                .then(textContent => {
                    const docxContentArea = contentElement.querySelector('.docx-content-area');
                    if (textContent && textContent.trim()) {
                        // Convert line breaks to HTML and preserve formatting
                        const formattedContent = textContent
                            .replace(/\n\n+/g, '</p><p>')
                            .replace(/\n/g, '<br>')
                            .replace(/^\s*/, '<p>')
                            .replace(/\s*$/, '</p>');

                        docxContentArea.innerHTML = `
                            <div class="docx-text-content">
                                ${formattedContent}
                            </div>
                        `;
                    } else {
                        docxContentArea.innerHTML = `
                            <div class="docx-error">
                                <div class="docx-error-icon">‚ö†Ô∏è</div>
                                <div class="docx-error-text">
                                    <strong>Content extraction failed</strong><br>
                                    Unable to extract readable text from this DOCX file.
                                </div>
                            </div>
                        `;
                    }
                })
                .catch(error => {
                    const docxContentArea = contentElement.querySelector('.docx-content-area');
                    docxContentArea.innerHTML = `
                        <div class="docx-error">
                            <div class="docx-error-icon">‚ö†Ô∏è</div>
                            <div class="docx-error-text">
                                <strong>Error loading DOCX:</strong><br>
                                ${error.message}
                            </div>
                        </div>
                    `;
                });
        }

        // Display email documents
        function displayEmailDocument(source, contentElement) {
            contentElement.innerHTML = `
                <div class="email-document-container">
                    <div class="email-content-area">
                        <div class="email-loading">
                            <div class="email-loading-spinner"></div>
                            <div>Loading email...</div>
                        </div>
                    </div>
                </div>
            `;

            // Request rendered email HTML via our Flask proxy endpoint
            fetch('{{ url_for("chat.render_email") }}?source=' + encodeURIComponent(source))
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Email file not found or not accessible');
                    }
                    return response.text();
                })
                .then(renderedHtml => {
                    const emailContentArea = contentElement.querySelector('.email-content-area');
                    if (renderedHtml && renderedHtml.trim()) {
                        emailContentArea.innerHTML = `
                            <div class="email-rendered-content">
                                ${renderedHtml}
                            </div>
                        `;
                    } else {
                        emailContentArea.innerHTML = `
                            <div class="email-error">
                                <div class="email-error-icon">‚ö†Ô∏è</div>
                                <div class="email-error-text">
                                    <strong>Content rendering failed</strong><br>
                                    Unable to render this email file.
                                </div>
                            </div>
                        `;
                    }
                })
                .catch(error => {
                    const emailContentArea = contentElement.querySelector('.email-content-area');
                    emailContentArea.innerHTML = `
                        <div class="email-error">
                            <div class="email-error-icon">‚ö†Ô∏è</div>
                            <div class="email-error-text">
                                <strong>Error loading email:</strong><br>
                                ${error.message}
                            </div>
                        </div>
                    `;
                });
        }

        // DOCX utility functions
        function downloadDocx(source) {
            const link = document.createElement('a');
            link.href = '{{ url_for("chat.get_document") }}?source=' + encodeURIComponent(source);
            link.download = decodeURIComponent(source.split('/').pop());
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Simple markdown to HTML converter
        function looksLikeMarkdown(content) {
            // Heuristic to detect if content is likely markdown
            // Count markdown patterns and if we find enough, consider it markdown
            let score = 0;
            const patterns = [];

            // Check for headers (# ## ###)
            if (/^#{1,6}\s+.+$/m.test(content)) {
                score += 2;
                patterns.push('headers');
            }

            // Check for multiple headers
            const headerMatches = content.match(/^#{1,6}\s+.+$/gm);
            if (headerMatches && headerMatches.length > 1) {
                score += 2;
                patterns.push('multiple-headers');
            }

            // Check for bold/italic (**text** or *text*)
            if (/\*\*[^*]+\*\*|\*[^*]+\*/.test(content)) {
                score += 1;
                patterns.push('bold/italic');
            }

            // Check for code blocks (```code```)
            if (/```[\s\S]*?```/.test(content)) {
                score += 3;
                patterns.push('code-blocks');
            }

            // Check for inline code (`code`)
            if (/`[^`\n]+`/.test(content)) {
                score += 1;
                patterns.push('inline-code');
            }

            // Check for links [text](url)
            if (/\[([^\]]+)\]\(([^)]+)\)/.test(content)) {
                score += 2;
                patterns.push('links');
            }

            // Check for markdown tables (| column | column |)
            if (/\|.+\|.+\|/.test(content)) {
                score += 2;
                patterns.push('tables');
            }

            // Check for lists (- item or * item or 1. item)
            if (/^[\*\-]\s+.+$/m.test(content)) {
                score += 1;
                patterns.push('unordered-lists');
            }
            if (/^\d+\.\s+.+$/m.test(content)) {
                score += 1;
                patterns.push('ordered-lists');
            }

            // Check for blockquotes (> text)
            if (/^>\s+.+$/m.test(content)) {
                score += 1;
                patterns.push('blockquotes');
            }

            // Check for horizontal rules (--- or ***)
            if (/^[\-\*]{3,}$/m.test(content)) {
                score += 1;
                patterns.push('hr');
            }

            // If score is 3 or higher, likely markdown
            // Lower threshold if we detect code blocks or tables (strong indicators)
            const hasCodeBlocks = /```[\s\S]*?```/.test(content);
            const hasTables = /\|.+\|.+\|/.test(content);
            const threshold = (hasCodeBlocks || hasTables) ? 2 : 3;
            const isMarkdown = score >= threshold;

            console.log('Markdown detection:', {
                score,
                threshold,
                isMarkdown,
                patterns,
                preview: content.substring(0, 100)
            });

            return isMarkdown;
        }

        function markdownToHtml(markdown) {
            let html = markdown;

            // Tables (must come before most other processing)
            html = html.replace(/^\|(.+)\|\s*$/gm, function (match) {
                const cells = match.split('|').slice(1, -1).map(cell => cell.trim());
                return '||' + cells.join('|') + '||';
            });

            // Process table blocks
            const tableRegex = /(\|\|.+\|\|(?:\n\|\|.+\|\|)+)/g;
            html = html.replace(tableRegex, function (tableBlock) {
                const rows = tableBlock.split('\n').filter(row => row.trim());
                if (rows.length < 2) return tableBlock;

                let tableHtml = '<table class="markdown-table">';

                rows.forEach((row, index) => {
                    const cells = row.split('|').slice(1, -1);

                    // Skip separator rows (like |-----|-----|)
                    if (cells.every(cell => /^[\s\-:]+$/.test(cell))) {
                        return;
                    }

                    const tag = index === 0 ? 'th' : 'td';
                    tableHtml += '<tr>';
                    cells.forEach(cell => {
                        tableHtml += `<${tag}>${cell.trim()}</${tag}>`;
                    });
                    tableHtml += '</tr>';
                });

                tableHtml += '</table>';
                return tableHtml;
            });

            // Headers (must come before other formatting)
            html = html.replace(/^### (.*$)/gim, '<h3>$1</h3>');
            html = html.replace(/^## (.*$)/gim, '<h2>$1</h2>');
            html = html.replace(/^# (.*$)/gim, '<h1>$1</h1>');

            // Bold and italic
            html = html.replace(/\*\*\*(.*?)\*\*\*/g, '<strong><em>$1</em></strong>');
            html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');

            // Code blocks (triple backticks)
            html = html.replace(/```(\w+)?\n([\s\S]*?)```/g, function (match, lang, code) {
                return `<pre class="code-block${lang ? ' language-' + lang : ''}"><code>${escapeHtml(code.trim())}</code></pre>`;
            });

            // Inline code
            html = html.replace(/`([^`]+)`/g, '<code class="inline-code">$1</code>');

            // Links
            html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener">$1</a>');

            // Horizontal rules
            html = html.replace(/^---+$/gm, '<hr>');

            // Unordered lists
            html = html.replace(/^\* (.+)$/gm, '<li>$1</li>');
            html = html.replace(/^\- (.+)$/gm, '<li>$1</li>');
            html = html.replace(/(<li>.*<\/li>)/gs, function (match) {
                return '<ul>' + match + '</ul>';
            });

            // Ordered lists
            html = html.replace(/^\d+\. (.+)$/gm, '<li>$1</li>');

            // Blockquotes
            html = html.replace(/^> (.+)$/gm, '<blockquote>$1</blockquote>');

            // Line breaks
            html = html.replace(/\n\n/g, '</p><p>');
            html = '<p>' + html + '</p>';

            // Clean up empty paragraphs and fix nested elements
            html = html.replace(/<p><\/p>/g, '');
            html = html.replace(/<p>(<h[1-6]>)/g, '$1');
            html = html.replace(/(<\/h[1-6]>)<\/p>/g, '$1');
            html = html.replace(/<p>(<hr>)<\/p>/g, '$1');
            html = html.replace(/<p>(<ul>)/g, '$1');
            html = html.replace(/(<\/ul>)<\/p>/g, '$1');
            html = html.replace(/<p>(<blockquote>)/g, '$1');
            html = html.replace(/(<\/blockquote>)<\/p>/g, '$1');
            html = html.replace(/<p>(<pre)/g, '$1');
            html = html.replace(/(<\/pre>)<\/p>/g, '$1');
            html = html.replace(/<p>(<table)/g, '$1');
            html = html.replace(/(<\/table>)<\/p>/g, '$1');

            return html;
        }

        // Display text documents
        function displayTextDocument(source, startIndex, contentElement, allowBinaryFallback = false) {
            fetch('{{ url_for("chat.get_document") }}?source=' + encodeURIComponent(source))
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Document not found or not accessible');
                    }
                    return response.text();
                })
                .then(content => {
                    contentElement.innerHTML = '';

                    // Check if content looks like binary data
                    if (allowBinaryFallback && isBinaryContent(content)) {
                        contentElement.innerHTML = `
                            <div style="text-align: center; padding: 40px; color: #7d8590;">
                                <div style="margin-bottom: 20px;">
                                    <strong>üìÑ Binary Document</strong><br>
                                    <small>Source: ${escapeHtml(source)}</small>
                                </div>
                                <div style="background: #161b22; border: 1px solid #30363d; padding: 20px; border-radius: 8px; font-family: monospace;">
                                    <div>File Type: ${source.split('.').pop().toUpperCase() || 'Unknown'}</div>
                                    <div>Size: ${content.length} bytes</div>
                                    <div style="margin-top: 10px; font-size: 0.8em;">
                                        This appears to be a binary file that cannot be displayed as text.
                                    </div>
                                </div>
                            </div>
                        `;
                        return;
                    }

                    // Check if this is a markdown file by extension or content
                    const hasMarkdownExtension = source.toLowerCase().endsWith('.md') || source.toLowerCase().endsWith('.markdown');
                    const contentLooksLikeMarkdown = looksLikeMarkdown(content);
                    const isMarkdown = hasMarkdownExtension || contentLooksLikeMarkdown;

                    if (isMarkdown) {
                        // Display markdown file with proper rendering
                        const fileName = decodeURIComponent(source.split('/').pop());
                        const fileTypeLabel = hasMarkdownExtension ? 'Markdown' : 'Markdown (detected)';
                        contentElement.innerHTML = `
                            <div class="markdown-document-container">
                                <div class="markdown-header">
                                    <div class="markdown-title">
                                        <span class="markdown-icon">üìù</span>
                                        <div class="markdown-info">
                                            <div class="markdown-name">${escapeHtml(fileName)}</div>
                                            <div class="markdown-source">Source: ${escapeHtml(decodeURIComponent(source))} ¬∑ ${fileTypeLabel}</div>
                                        </div>
                                    </div>
                                    <div class="markdown-actions">
                                        <button onclick="downloadMarkdown('${encodeURIComponent(source)}')" class="markdown-btn" title="Download Markdown">
                                            <span class="markdown-btn-icon">‚¨á</span>
                                        </button>
                                        <button onclick="openMarkdownInNewTab('${encodeURIComponent(source)}')" class="markdown-btn" title="Open in New Tab">
                                            <span class="markdown-btn-icon">üîó</span>
                                        </button>
                                    </div>
                                </div>
                                <div class="markdown-content">
                                    ${markdownToHtml(content)}
                                </div>
                            </div>
                        `;
                    } else {
                        // Display as text with highlighting for non-markdown files
                        if (startIndex > 0 && content.length > startIndex) {
                            const beforeChunk = content.substring(0, startIndex);
                            const chunkContent = content.substring(startIndex, Math.min(startIndex + 500, content.length));
                            const afterChunk = content.substring(Math.min(startIndex + 500, content.length));

                            contentElement.innerHTML = escapeHtml(beforeChunk) +
                                '<span class="highlighted-chunk">' + escapeHtml(chunkContent) + '</span>' +
                                escapeHtml(afterChunk);

                            // Scroll to highlighted section
                            setTimeout(() => {
                                const highlighted = contentElement.querySelector('.highlighted-chunk');
                                if (highlighted) {
                                    highlighted.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                }
                            }, 100);
                        } else {
                            contentElement.textContent = content;
                        }
                    }
                })
                .catch(error => {
                    contentElement.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: #f85149;">
                            <strong>Error loading document:</strong><br>
                            ${error.message}
                        </div>
                    `;
                });
        }

        // Check if content appears to be binary
        function isBinaryContent(content) {
            // Check for null bytes or high ratio of non-printable characters
            if (content.includes('\0')) return true;

            let nonPrintable = 0;
            for (let i = 0; i < Math.min(content.length, 1000); i++) {
                const code = content.charCodeAt(i);
                if (code < 32 && code !== 9 && code !== 10 && code !== 13) {
                    nonPrintable++;
                }
            }

            return (nonPrintable / Math.min(content.length, 1000)) > 0.1;
        }

        // Escape HTML for safe display
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // PDF utility functions
        function downloadPdf(source) {
            const link = document.createElement('a');
            link.href = '{{ url_for("chat.get_document") }}?source=' + encodeURIComponent(source);
            link.download = decodeURIComponent(source.split('/').pop()); // Extract filename
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function openPdfInNewTab(source) {
            // Open PDF directly in new tab using our document route
            const newWindow = window.open('{{ url_for("chat.get_document") }}?source=' + encodeURIComponent(source), '_blank');
            if (!newWindow) {
                alert('Popup blocked! Please allow popups for this site to view PDF files in new tabs.');
            }
        }

        // Markdown utility functions
        function downloadMarkdown(source) {
            const link = document.createElement('a');
            link.href = '{{ url_for("chat.get_document") }}?source=' + encodeURIComponent(source);
            link.download = decodeURIComponent(source.split('/').pop());
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function openMarkdownInNewTab(source) {
            // Fetch the markdown content and display rendered HTML in new tab
            fetch('{{ url_for("chat.get_document") }}?source=' + encodeURIComponent(source))
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Markdown file not accessible');
                    }
                    return response.text();
                })
                .then(markdownContent => {
                    const newWindow = window.open('', '_blank');
                    if (newWindow) {
                        const fileName = decodeURIComponent(source.split('/').pop());
                        const renderedHtml = markdownToHtml(markdownContent);

                        newWindow.document.write(`
                            <!DOCTYPE html>
                            <html>
                            <head>
                                <title>${fileName}</title>
                                <meta charset="utf-8">
                                <style>
                                    body { 
                                        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                                        max-width: 800px;
                                        margin: 0 auto;
                                        padding: 20px;
                                        background: #0d1117; 
                                        color: #e6edf3;
                                        line-height: 1.6;
                                    }
                                    .header {
                                        border-bottom: 1px solid #21262d;
                                        padding-bottom: 15px;
                                        margin-bottom: 30px;
                                    }
                                    .header h1 { 
                                        color: #58a6ff; 
                                        font-size: 1.8em;
                                        margin: 0 0 5px 0;
                                    }
                                    .header .info { 
                                        color: #7d8590; 
                                        font-size: 0.9em;
                                    }
                                    h1, h2, h3, h4, h5, h6 { color: #58a6ff; margin-top: 2em; margin-bottom: 0.5em; }
                                    h1 { font-size: 2em; border-bottom: 1px solid #21262d; padding-bottom: 0.3em; }
                                    h2 { font-size: 1.5em; border-bottom: 1px solid #21262d; padding-bottom: 0.3em; }
                                    h3 { font-size: 1.25em; }
                                    p { margin-bottom: 1em; }
                                    a { color: #58a6ff; text-decoration: none; }
                                    a:hover { text-decoration: underline; }
                                    code.inline-code { 
                                        background: #161b22; 
                                        color: #f0883e;
                                        padding: 2px 6px; 
                                        border-radius: 3px; 
                                        font-family: 'SF Mono', Consolas, monospace;
                                        font-size: 0.9em;
                                    }
                                    pre.code-block { 
                                        background: #161b22; 
                                        border: 1px solid #30363d;
                                        border-radius: 6px;
                                        padding: 16px; 
                                        overflow: auto;
                                        margin: 1em 0;
                                    }
                                    pre.code-block code {
                                        color: #e6edf3;
                                        font-family: 'SF Mono', Consolas, monospace;
                                        font-size: 0.9em;
                                    }
                                    ul, ol { padding-left: 2em; margin: 1em 0; }
                                    li { margin: 0.25em 0; }
                                    blockquote { 
                                        border-left: 4px solid #30363d; 
                                        padding-left: 16px; 
                                        margin: 1em 0;
                                        color: #7d8590;
                                        background: rgba(22, 27, 34, 0.5);
                                        border-radius: 0 6px 6px 0;
                                        padding: 8px 16px;
                                    }
                                    hr { 
                                        border: none; 
                                        border-top: 1px solid #21262d; 
                                        margin: 2em 0; 
                                    }
                                    strong { color: #f0f6fc; }
                                    em { color: #f0f6fc; font-style: italic; }
                                </style>
                            </head>
                            <body>
                                <div class="header">
                                    <h1>üìù ${fileName}</h1>
                                    <div class="info">Source: ${decodeURIComponent(source)}</div>
                                </div>
                                <div class="content">
                                    ${renderedHtml}
                                </div>
                            </body>
                            </html>
                        `);
                        newWindow.document.close();
                    } else {
                        alert('Popup blocked! Please allow popups for this site to view markdown files in new tabs.');
                    }
                })
                .catch(error => {
                    alert('Error opening markdown file: ' + error.message);
                });
        }

        // Handle escape key to close document viewer
        document.addEventListener('keydown', function (e) {
            if (e.key === 'Escape') {
                closeDocumentViewer();
            }
        });

        // Load source context and re-run query
        async function loadSourceContext(button) {
            const sourcePath = button.getAttribute('data-source-path');

            // Disable button and show loading
            const originalText = button.innerHTML;
            button.disabled = true;
            button.innerHTML = '<span class="load-icon">‚è≥</span> Loading...';

            try {
                const response = await fetch('/load_source', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        source_path: sourcePath
                    })
                });

                const result = await response.json();

                if (!response.ok) {
                    throw new Error(result.error || 'Failed to load source');
                }

                // Store the loaded context in a hidden form field
                let contextInput = document.getElementById('loaded_context');
                if (!contextInput) {
                    contextInput = document.createElement('input');
                    contextInput.type = 'hidden';
                    contextInput.id = 'loaded_context';
                    contextInput.name = 'loaded_context';
                    document.getElementById('chat-form').appendChild(contextInput);
                }

                // Store metadata about the loaded source
                let sourceMetaInput = document.getElementById('loaded_source_meta');
                if (!sourceMetaInput) {
                    sourceMetaInput = document.createElement('input');
                    sourceMetaInput.type = 'hidden';
                    sourceMetaInput.id = 'loaded_source_meta';
                    sourceMetaInput.name = 'loaded_source_meta';
                    document.getElementById('chat-form').appendChild(sourceMetaInput);
                }

                contextInput.value = result.enhanced_context;
                sourceMetaInput.value = JSON.stringify({
                    source_path: result.source_path,
                    context_type: result.context_type
                });

                // Update button to show success
                button.innerHTML = '<span class="load-icon">‚úÖ</span> Loaded';
                button.style.backgroundColor = '#28a745';
                button.style.color = 'white';

                // Show a temporary notification
                showNotification(`Loaded context from ${sourcePath.split('/').pop()}. It will be included with your next question.`, 'success');

            } catch (error) {
                console.error('Error loading source:', error);
                showNotification('Error loading source: ' + error.message, 'error');

                // Restore button
                button.disabled = false;
                button.innerHTML = originalText;
            }
        }

        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.textContent = message;
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 12px 20px;
                border-radius: 6px;
                color: white;
                font-weight: 500;
                z-index: 1000;
                max-width: 400px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                ${type === 'success' ? 'background-color: #28a745;' : ''}
                ${type === 'error' ? 'background-color: #dc3545;' : ''}
                ${type === 'info' ? 'background-color: #17a2b8;' : ''}
            `;

            document.body.appendChild(notification);

            // Remove after 5 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 5000);
        }

        // Document Browser Functions
        let allDocuments = [];

        async function openDocumentBrowser() {
            const modal = document.getElementById('document-browser-modal');
            modal.style.display = 'flex';
            
            // Fetch documents from the RAG system
            try {
                const response = await fetch('/browse_documents');
                const result = await response.json();
                
                if (!response.ok) {
                    throw new Error(result.error || 'Failed to fetch documents');
                }
                
                allDocuments = result.documents || [];
                displayDocuments(allDocuments);
                
            } catch (error) {
                console.error('Error fetching documents:', error);
                document.getElementById('document-list').innerHTML = `
                    <div class="error-message">Error loading documents: ${error.message}</div>
                `;
            }
        }

        function closeDocumentBrowser() {
            const modal = document.getElementById('document-browser-modal');
            modal.style.display = 'none';
            document.getElementById('doc-search').value = '';
        }

        function displayDocuments(documents) {
            const docList = document.getElementById('document-list');
            
            if (documents.length === 0) {
                docList.innerHTML = '<div class="no-documents">No documents found in RAG system</div>';
                return;
            }
            
            docList.innerHTML = documents.map(doc => `
                <div class="browser-doc-item">
                    <div class="browser-doc-info">
                        <span class="browser-doc-filename">${doc.filename}</span>
                        <span class="browser-doc-path">${doc.path}</span>
                        ${doc.is_csv ? '<span class="doc-badge csv-badge">CSV</span>' : 
                          doc.file_type ? `<span class="doc-badge">${doc.file_type.toUpperCase()}</span>` : ''}
                    </div>
                    <div class="browser-doc-actions">
                        <button class="browser-load-btn" onclick="loadDocumentFromBrowser('${doc.path.replace(/'/g, "\\'")}', this)">
                            üì• Load ${doc.is_csv ? '(Full CSV)' : '(All Chunks)'}
                        </button>
                        <button class="browser-view-btn view-doc-btn" data-source="${doc.path}">
                            üëÅÔ∏è View
                        </button>
                    </div>
                </div>
            `).join('');
        }

        function filterDocuments() {
            const searchTerm = document.getElementById('doc-search').value.toLowerCase();
            
            if (!searchTerm) {
                displayDocuments(allDocuments);
                return;
            }
            
            const filtered = allDocuments.filter(doc => 
                doc.filename.toLowerCase().includes(searchTerm) ||
                doc.path.toLowerCase().includes(searchTerm)
            );
            
            displayDocuments(filtered);
        }

        async function loadDocumentFromBrowser(sourcePath, button) {
            const originalText = button.innerHTML;
            button.disabled = true;
            button.innerHTML = '‚è≥ Loading...';
            
            try {
                const response = await fetch('/load_source', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        source_path: sourcePath
                    })
                });

                const result = await response.json();

                if (!response.ok) {
                    throw new Error(result.error || 'Failed to load source');
                }

                // Store the loaded context in hidden form fields
                document.getElementById('loaded-context').value = result.enhanced_context;
                document.getElementById('loaded-source-meta').value = JSON.stringify({
                    source_path: result.source_path,
                    context_type: result.context_type
                });

                // Update button to show success
                button.innerHTML = '‚úÖ Loaded';
                button.style.backgroundColor = '#28a745';
                button.style.color = 'white';

                // Show notification
                const filename = sourcePath.split('/').pop();
                showNotification(`Loaded context from ${filename}. It will be included with your next question.`, 'success');
                
                // Close modal after 1 second
                setTimeout(() => {
                    closeDocumentBrowser();
                }, 1000);

            } catch (error) {
                console.error('Error loading document:', error);
                showNotification('Error loading document: ' + error.message, 'error');
                button.disabled = false;
                button.innerHTML = originalText;
            }
        }

        // Close modal when clicking outside
        document.addEventListener('click', function(e) {
            const modal = document.getElementById('document-browser-modal');
            if (e.target === modal) {
                closeDocumentBrowser();
            }
        });

        // Download assistant response as markdown
        function downloadMarkdownResponse(messageIndex, button) {
            // Get all messages
            const messages = {{ message_history | tojson }};
            
            if (messageIndex >= messages.length) {
                showNotification('Message not found', 'error');
                return;
            }
            
            const message = messages[messageIndex];
            
            // Only download if it's an assistant message
            if (message.role !== 'assistant') {
                showNotification('Can only download assistant responses', 'error');
                return;
            }
            
            const markdownContent = message.content;
            
            // Create a blob with the markdown content
            const blob = new Blob([markdownContent], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            
            // Create a temporary link and trigger download
            const a = document.createElement('a');
            a.href = url;
            a.download = `response-${Date.now()}.md`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showNotification('Markdown downloaded', 'success');
        }

        // File upload functionality
        function openFileUpload() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.pdf,.txt,.md,.csv,.docx,.doc,.json,.xml,.html';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    uploadFileToRAG(file);
                }
            };
            input.click();
        }

        async function uploadFileToRAG(file) {
            if (!file) {
                showNotification('No file selected', 'error');
                return;
            }

            const formData = new FormData();
            formData.append('file', file);

            try {
                showNotification(`Uploading ${file.name}...`, 'info');

                console.log('Uploading file:', file.name);
                
                // Use our proxy endpoint to avoid CORS issues
                const response = await fetch('/upload_to_rag', {
                    method: 'POST',
                    body: formData
                });

                console.log('Upload response status:', response.status);

                if (!response.ok) {
                    // Try to get error details
                    let errorMessage = 'Upload failed';
                    try {
                        const result = await response.json();
                        errorMessage = result.error || result.detail || result.message || errorMessage;
                    } catch {
                        errorMessage = `Upload failed with status ${response.status}`;
                    }
                    throw new Error(errorMessage);
                }

                const result = await response.json();
                console.log('Upload result:', result);

                showNotification(`File "${file.name}" uploaded successfully! It will appear in Browse Documents shortly.`, 'success');

            } catch (error) {
                console.error('Error uploading file:', error);
                showNotification(`Error uploading file: ${error.message}`, 'error');
            }
        }
    </script>
</body>

</html>