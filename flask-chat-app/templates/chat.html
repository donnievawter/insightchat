<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>InsightChat - AI Chat with RAG</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>

<body>
    <div class="chat-container">
        <div class="chat-header">
            <h1>InsightChat</h1>
            <form method="POST" action="{{ url_for('chat.reset') }}" style="display: inline;">
                <button type="submit" class="reset-btn">Reset Chat</button>
            </form>
        </div>

        <div class="chat-settings">
            <div class="settings-row">
                <label for="model">Model:</label>
                <select name="model" id="model" form="chat-form">
                    {% for model_info in available_models %}
                    <option value="{{ model_info.name }}" {{ 'selected' if model==model_info.name else '' }}>
                        {{ model_info.name }}
                        {% if model_info.parameter_size %}({{ model_info.parameter_size }}){% endif %}
                    </option>
                    {% endfor %}
                </select>

                <label for="use_repo_docs">
                    <input type="checkbox" name="use_repo_docs" id="use_repo_docs" form="chat-form" {{ 'checked' if
                        use_repo_docs else '' }}>
                    Use RAG Context
                </label>
            </div>
        </div>

        {% if error %}
        <div class="error-message">{{ error }}</div>
        {% endif %}

        <div class="chat-messages" id="chat-messages">
            {% for message in message_history %}
            <div class="message {{ message.role }}">
                <div class="message-header">
                    <span class="message-role">{{ message.role.title() }}</span>
                    {% if message.role == 'assistant' and message.get('sources') %}
                    <button class="toggle-chunks-btn" onclick="toggleChunks('{{ loop.index }}')">
                        <span id="chunks-icon-{{ loop.index }}">📄</span>
                        <span id="chunks-text-{{ loop.index }}">Show Sources ({{ message.sources|length }})</span>
                    </button>
                    {% elif message.role == 'assistant' and message.get('rag_chunks') %}
                    <button class="toggle-chunks-btn" onclick="toggleChunks('{{ loop.index }}')">
                        <span id="chunks-icon-{{ loop.index }}">�</span>
                        <span id="chunks-text-{{ loop.index }}">Show Sources ({{ message.rag_chunks|length }})</span>
                    </button>
                    {% endif %}
                </div>
                <div class="message-content">{{ message.content | safe }}</div>

                {% if message.role == 'assistant' and message.get('sources') %}
                <div class="sources-section" id="chunks-{{ loop.index }}" style="display: none;">
                    <div class="sources-header">
                        <h4>Available Sources</h4>
                        <p class="sources-help">Click "Load" to expand context with full content from that source</p>
                    </div>
                    {% set outer_loop = loop %}
                    {% for source in message.sources %}
                    <div class="source-item">
                        <div class="source-header">
                            <span class="source-filename">{{ source.filename }}</span>
                            <span class="source-path">{{ source.path }}</span>
                            {% if source.is_csv %}
                            <span class="source-type csv-badge">CSV</span>
                            {% else %}
                            <span class="source-type">{{ source.file_type.upper() }}</span>
                            {% endif %}
                        </div>
                        <div class="source-actions">
                            <button class="load-source-btn" data-source-path="{{ source.path }}"
                                data-message-index="{{ outer_loop.index0 }}" onclick="loadSourceContext(this)">
                                <span class="load-icon">📥</span>
                                Load
                                {% if source.is_csv %}(Full CSV){% else %}(All Chunks){% endif %}
                            </button>
                            <button class="view-doc-btn" data-source="{{ source.path }}">
                                View Document
                            </button>
                        </div>
                    </div>
                    {% endfor %}
                </div>
                {% elif message.role == 'assistant' and message.get('rag_chunks') %}
                <div class="rag-chunks" id="chunks-{{ loop.index }}" style="display: none;">
                    <div class="chunks-header">
                        <h4>Retrieved Context Sources</h4>
                    </div>
                    {% set outer_loop = loop %}
                    {% for chunk in message.rag_chunks %}
                    <div class="chunk-item">
                        <div class="chunk-header">
                            <span class="chunk-source">{{ chunk.metadata.get('source', 'Unknown Source') }}</span>
                            {% if chunk.metadata.get('page') %}
                            <span class="chunk-page">Page {{ chunk.metadata.page }}</span>
                            {% endif %}
                            <button class="view-doc-btn" data-source="{{ chunk.metadata.get('source', '') }}"
                                data-start-index="{{ chunk.get('start_index', 0) }}">
                                View Document
                            </button>
                        </div>
                        <div class="chunk-content">
                            <p>{{ chunk.content[:200] }}{% if chunk.content|length > 200 %}...{% endif %}</p>
                        </div>
                        <div class="chunk-actions">
                            <button class="expand-chunk-btn"
                                onclick="toggleChunkExpansion('msg{{ outer_loop.index }}_chunk{{ loop.index0 }}')">
                                <span id="chunk-expand-msg{{ outer_loop.index }}_chunk{{ loop.index0 }}">Show
                                    More</span>
                            </button>
                            <div class="chunk-full-content"
                                id="chunk-full-msg{{ outer_loop.index }}_chunk{{ loop.index0 }}" style="display: none;">
                                <p>{{ chunk.content }}</p>
                            </div>
                        </div>
                    </div>
                    {% endfor %}
                </div>
                {% endif %}


            </div>
            {% endfor %}
        </div>

        <form id="chat-form" method="POST" action="{{ url_for('chat.chat') }}">
            <div class="input-row">
                <input type="text" name="prompt" placeholder="Type your message..." required>
                <button type="submit">Send</button>
            </div>
        </form>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // Auto-scroll to bottom of messages
            const chatMessages = document.getElementById('chat-messages');
            if (chatMessages) {
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }

            // Focus on input field
            const promptInput = document.querySelector('input[name="prompt"]');
            if (promptInput) {
                promptInput.focus();
            }

            // Handle form submission to disable/enable send button
            const chatForm = document.getElementById('chat-form');
            const sendButton = chatForm ? chatForm.querySelector('button[type="submit"]') : null;

            if (chatForm && sendButton) {
                const originalButtonText = sendButton.textContent;

                chatForm.addEventListener('submit', function (e) {
                    const message = promptInput.value.trim();
                    if (!message) {
                        e.preventDefault();
                        return;
                    }

                    // Disable button and show loading state
                    sendButton.disabled = true;
                    sendButton.textContent = 'Sending...';
                });
            }

            // Handle view document buttons
            document.addEventListener('click', function (e) {
                if (e.target.classList.contains('view-doc-btn')) {
                    const source = e.target.getAttribute('data-source');
                    const startIndex = parseInt(e.target.getAttribute('data-start-index') || '0');
                    viewDocument(source, startIndex);
                }
            });
        });

        // Toggle chunks display
        function toggleChunks(messageIndex) {
            const chunksDiv = document.getElementById('chunks-' + messageIndex);
            const icon = document.getElementById('chunks-icon-' + messageIndex);
            const text = document.getElementById('chunks-text-' + messageIndex);

            if (chunksDiv.style.display === 'none') {
                chunksDiv.style.display = 'block';
                icon.textContent = '📂';
                text.textContent = text.textContent.replace('Show', 'Hide');
            } else {
                chunksDiv.style.display = 'none';
                icon.textContent = '📄';
                text.textContent = text.textContent.replace('Hide', 'Show');
            }
        }

        // Toggle individual chunk expansion
        function toggleChunkExpansion(chunkIndex) {
            const fullContent = document.getElementById('chunk-full-' + chunkIndex);
            const expandBtn = document.getElementById('chunk-expand-' + chunkIndex);

            if (fullContent && expandBtn) {
                if (fullContent.style.display === 'none') {
                    fullContent.style.display = 'block';
                    expandBtn.textContent = 'Show Less';
                } else {
                    fullContent.style.display = 'none';
                    expandBtn.textContent = 'Show More';
                }
            }
        }

        // View document in modal
        function viewDocument(source, startIndex = 0) {
            // Create modal overlay
            const overlay = document.createElement('div');
            overlay.className = 'document-viewer-overlay';
            overlay.onclick = function (e) {
                if (e.target === overlay) {
                    closeDocumentViewer();
                }
            };

            // Create document viewer
            const viewer = document.createElement('div');
            viewer.className = 'document-viewer';

            // Create header
            const header = document.createElement('div');
            header.className = 'document-viewer-header';
            header.innerHTML = `
                <h3>${source}</h3>
                <button class="document-viewer-close" onclick="closeDocumentViewer()">Close</button>
            `;

            // Create content area
            const content = document.createElement('div');
            content.className = 'document-viewer-content';
            content.innerHTML = '<div style="text-align: center; padding: 40px; color: #7d8590;">Loading document...</div>';

            viewer.appendChild(header);
            viewer.appendChild(content);
            overlay.appendChild(viewer);
            document.body.appendChild(overlay);

            // Fetch document content
            fetchDocumentContent(source, startIndex, content);
        }

        // Close document viewer
        function closeDocumentViewer() {
            const overlay = document.querySelector('.document-viewer-overlay');
            if (overlay) {
                overlay.remove();
            }
        }

        // Fetch and display document content
        function fetchDocumentContent(source, startIndex, contentElement) {
            // Determine file type from extension
            const fileExtension = source.split('.').pop().toLowerCase();
            const imageExtensions = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'svg', 'bmp'];
            const textExtensions = ['txt', 'md', 'py', 'js', 'html', 'css', 'json', 'xml', 'yaml', 'yml', 'sh', 'conf', 'log'];
            const pdfExtensions = ['pdf'];
            const csvExtensions = ['csv', 'tsv'];
            const docxExtensions = ['docx', 'doc'];

            if (imageExtensions.includes(fileExtension)) {
                // Display image
                displayImageDocument(source, contentElement);
            } else if (pdfExtensions.includes(fileExtension)) {
                // Display PDF
                displayPdfDocument(source, contentElement);
            } else if (csvExtensions.includes(fileExtension)) {
                // Display CSV as table
                displayCsvDocument(source, contentElement);
            } else if (docxExtensions.includes(fileExtension)) {
                // Display DOCX document
                displayDocxDocument(source, contentElement);
            } else if (textExtensions.includes(fileExtension)) {
                // Display as text
                displayTextDocument(source, startIndex, contentElement);
            } else {
                // Try to display as text first, fallback to binary info
                displayTextDocument(source, startIndex, contentElement, true);
            }
        }

        // Display image documents
        function displayImageDocument(source, contentElement) {
            contentElement.innerHTML = `
                <div style="text-align: center; padding: 20px;">
                    <div style="margin-bottom: 20px; color: #58a6ff;">
                        <strong>📷 Image Document</strong><br>
                        <small>Source: ${escapeHtml(source)}</small>
                    </div>
                    <div style="max-width: 100%; overflow: auto;">
                        <img src="{{ url_for('chat.get_document') }}?source=${encodeURIComponent(source)}" 
                             alt="${escapeHtml(source)}" 
                             style="max-width: 100%; height: auto; border: 1px solid #30363d; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.3);"
                             onload="this.style.display='block'" 
                             onerror="this.style.display='none'; this.nextElementSibling.style.display='block'">
                        <div style="display: none; padding: 20px; background: #2d1b20; border: 1px solid #da3633; border-radius: 8px; color: #f97583;">
                            <strong>Error loading image</strong><br>
                            The image could not be displayed. It may be corrupted or in an unsupported format.
                        </div>
                    </div>
                    <div style="margin-top: 20px; font-size: 0.9em; color: #7d8590;">
                        This image was referenced in the RAG context. 
                        <br>For text content, check if there are associated description files.
                    </div>
                </div>
            `;
        }

        // Display PDF documents
        function displayPdfDocument(source, contentElement) {
            contentElement.innerHTML = `
                <div class="pdf-document-container">
                    <div class="pdf-header">
                        <div class="pdf-title">
                            <span class="pdf-icon">📄</span>
                            <div class="pdf-info">
                                <div class="pdf-name">${escapeHtml(decodeURIComponent(source.split('/').pop()))}</div>
                                <div class="pdf-source">Source: ${escapeHtml(decodeURIComponent(source))}</div>
                            </div>
                        </div>
                        <div class="pdf-actions">
                            <button onclick="downloadPdf('${encodeURIComponent(source)}')" class="pdf-btn pdf-download-btn" title="Download PDF">
                                <span class="pdf-btn-icon">⬇</span>
                            </button>
                            <button onclick="openPdfInNewTab('${encodeURIComponent(source)}')" class="pdf-btn pdf-newtab-btn" title="Open in New Tab">
                                <span class="pdf-btn-icon">↗</span>
                            </button>
                        </div>
                    </div>
                    <div class="pdf-viewer-frame">
                        <iframe id="pdf-viewer-${Date.now()}" 
                                src="{{ url_for('chat.get_document') }}?source=${encodeURIComponent(source)}" 
                                class="pdf-iframe"
                                onload="this.style.display='block'; this.nextElementSibling.style.display='none';"
                                onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                        </iframe>
                        <div class="pdf-error-fallback" style="display: none;">
                            <div class="pdf-error-content">
                                <div class="pdf-error-icon">⚠️</div>
                                <div class="pdf-error-text">
                                    <strong>PDF Preview Unavailable</strong><br>
                                    <span>Your browser doesn't support inline PDF viewing</span>
                                </div>
                                <button onclick="downloadPdf('${encodeURIComponent(source)}')" class="pdf-error-btn">
                                    Download PDF
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        // Display CSV documents as tables
        function displayCsvDocument(source, contentElement) {
            contentElement.innerHTML = `
                <div class="csv-document-container">
                    <div class="csv-header">
                        <div class="csv-title">
                            <span class="csv-icon">📊</span>
                            <div class="csv-info">
                                <div class="csv-name">${escapeHtml(decodeURIComponent(source.split('/').pop()))}</div>
                                <div class="csv-source">Source: ${escapeHtml(decodeURIComponent(source))}</div>
                            </div>
                        </div>
                        <div class="csv-actions">
                            <button onclick="downloadCsv('${encodeURIComponent(source)}')" class="csv-btn csv-download-btn" title="Download CSV">
                                <span class="csv-btn-icon">⬇</span>
                            </button>
                            <button onclick="openCsvInNewTab('${encodeURIComponent(source)}')" class="csv-btn csv-newtab-btn" title="Open Raw CSV">
                                <span class="csv-btn-icon">↗</span>
                            </button>
                        </div>
                    </div>
                    <div class="csv-content-area">
                        <div class="csv-loading">Loading CSV data...</div>
                    </div>
                </div>
            `;

            // Fetch and parse CSV data
            fetch('{{ url_for("chat.get_document") }}?source=' + encodeURIComponent(source))
                .then(response => {
                    if (!response.ok) {
                        throw new Error('CSV file not found or not accessible');
                    }
                    return response.text();
                })
                .then(csvData => {
                    const csvContentArea = contentElement.querySelector('.csv-content-area');
                    const tableHtml = parseCsvToTable(csvData, source);
                    csvContentArea.innerHTML = tableHtml;
                })
                .catch(error => {
                    const csvContentArea = contentElement.querySelector('.csv-content-area');
                    csvContentArea.innerHTML = `
                        <div class="csv-error">
                            <div class="csv-error-icon">⚠️</div>
                            <div class="csv-error-text">
                                <strong>Error loading CSV:</strong><br>
                                ${error.message}
                            </div>
                        </div>
                    `;
                });
        }

        // Parse CSV data and convert to HTML table
        function parseCsvToTable(csvData, source) {
            const lines = csvData.trim().split('\n');
            if (lines.length === 0) {
                return '<div class="csv-error">Empty CSV file</div>';
            }

            // Detect delimiter - check for common separators
            const firstLine = lines[0];
            let delimiter = ',';
            if (source.toLowerCase().endsWith('.tsv') || firstLine.includes('\t')) {
                delimiter = '\t';
            } else if (firstLine.split(';').length > firstLine.split(',').length) {
                delimiter = ';';
            }

            // Parse CSV rows
            const rows = lines.map(line => parseCsvLine(line, delimiter));

            if (rows.length === 0) {
                return '<div class="csv-error">No data found in CSV</div>';
            }

            // Build HTML table
            let tableHtml = `
                <div class="csv-info-bar">
                    <span class="csv-stats">${rows.length - 1} rows × ${rows[0]?.length || 0} columns</span>
                    <span class="csv-delimiter">Delimiter: ${delimiter === '\t' ? 'Tab' : delimiter}</span>
                </div>
                <div class="csv-table-wrapper">
                    <table class="csv-table">
            `;

            // Add header row (assume first row is headers)
            if (rows[0]) {
                tableHtml += '<thead><tr>';
                rows[0].forEach(cell => {
                    tableHtml += `<th>${escapeHtml(cell)}</th>`;
                });
                tableHtml += '</tr></thead>';
            }

            // Add data rows
            tableHtml += '<tbody>';
            const dataRows = rows.slice(1); // Skip header row
            const maxRows = 1000; // Limit for performance
            const displayRows = dataRows.slice(0, maxRows);

            displayRows.forEach(row => {
                tableHtml += '<tr>';
                row.forEach(cell => {
                    tableHtml += `<td>${escapeHtml(cell)}</td>`;
                });
                tableHtml += '</tr>';
            });

            if (dataRows.length > maxRows) {
                tableHtml += `
                    <tr class="csv-truncated-notice">
                        <td colspan="${rows[0]?.length || 1}">
                            <em>... ${dataRows.length - maxRows} more rows (showing first ${maxRows} rows)</em>
                        </td>
                    </tr>
                `;
            }

            tableHtml += '</tbody></table></div>';
            return tableHtml;
        }

        // Simple CSV line parser (handles quoted fields)
        function parseCsvLine(line, delimiter = ',') {
            const result = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];

                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === delimiter && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }

            result.push(current.trim());
            return result;
        }

        // CSV utility functions
        function downloadCsv(source) {
            const link = document.createElement('a');
            link.href = '{{ url_for("chat.get_document") }}?source=' + encodeURIComponent(source);
            link.download = decodeURIComponent(source.split('/').pop());
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function openCsvInNewTab(source) {
            // Fetch the CSV content and display in new tab
            fetch('{{ url_for("chat.get_document") }}?source=' + encodeURIComponent(source))
                .then(response => {
                    if (!response.ok) {
                        throw new Error('CSV file not accessible');
                    }
                    return response.text();
                })
                .then(csvContent => {
                    // Create a new window and write HTML content to display the CSV
                    const newWindow = window.open('', '_blank');
                    if (newWindow) {
                        const fileName = decodeURIComponent(source.split('/').pop());
                        const tableHtml = parseCsvToTable(csvContent, source);

                        newWindow.document.write(`
                            <!DOCTYPE html>
                            <html>
                            <head>
                                <title>${fileName}</title>
                                <style>
                                    body { 
                                        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                                        margin: 20px; 
                                        background: #0d1117; 
                                        color: #e6edf3;
                                    }
                                    h1 { 
                                        color: #58a6ff; 
                                        font-size: 1.5em;
                                        margin-bottom: 10px;
                                    }
                                    .info { 
                                        color: #7d8590; 
                                        margin-bottom: 20px; 
                                        font-size: 0.9em;
                                    }
                                    .csv-table-wrapper {
                                        border: 1px solid #21262d;
                                        border-radius: 6px;
                                        overflow: auto;
                                        max-height: 80vh;
                                    }
                                    .csv-table {
                                        width: 100%;
                                        border-collapse: collapse;
                                        font-size: 0.85em;
                                        background: #0d1117;
                                    }
                                    .csv-table th {
                                        background: #161b22;
                                        color: #58a6ff;
                                        font-weight: 600;
                                        padding: 8px 12px;
                                        text-align: left;
                                        border-bottom: 2px solid #30363d;
                                        border-right: 1px solid #21262d;
                                        position: sticky;
                                        top: 0;
                                        z-index: 100;
                                        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                                    }
                                    .csv-table th:last-child { border-right: none; }
                                    .csv-table td {
                                        padding: 6px 12px;
                                        border-bottom: 1px solid #21262d;
                                        border-right: 1px solid #21262d;
                                        color: #e6edf3;
                                        white-space: nowrap;
                                        overflow: hidden;
                                        text-overflow: ellipsis;
                                        max-width: 200px;
                                    }
                                    .csv-table td:last-child { border-right: none; }
                                    .csv-table tbody tr:hover { background: #161b22; }
                                    .csv-table tbody tr:nth-child(even) { background: rgba(22, 27, 34, 0.5); }
                                    .csv-table tbody tr:nth-child(even):hover { background: #161b22; }
                                    .csv-info-bar {
                                        display: flex;
                                        justify-content: space-between;
                                        padding: 8px 12px;
                                        background: #161b22;
                                        border-bottom: 1px solid #21262d;
                                        font-size: 0.8em;
                                        color: #7d8590;
                                    }
                                </style>
                            </head>
                            <body>
                                <h1>📊 ${fileName}</h1>
                                <div class="info">Source: ${decodeURIComponent(source)}</div>
                                ${tableHtml}
                            </body>
                            </html>
                        `);
                        newWindow.document.close();
                    } else {
                        alert('Popup blocked! Please allow popups for this site to view CSV files in new tabs.');
                    }
                })
                .catch(error => {
                    alert('Error opening CSV file: ' + error.message);
                });
        }

        // Display DOCX documents
        function displayDocxDocument(source, contentElement) {
            const fileName = decodeURIComponent(source.split('/').pop());
            contentElement.innerHTML = `
                <div class="docx-document-container">
                    <div class="docx-header">
                        <div class="docx-title">
                            <span class="docx-icon">📄</span>
                            <div class="docx-info">
                                <div class="docx-name">${escapeHtml(fileName)}</div>
                                <div class="docx-source">Source: ${escapeHtml(decodeURIComponent(source))}</div>
                            </div>
                        </div>
                        <div class="docx-actions">
                            <button onclick="downloadDocx('${encodeURIComponent(source)}')" class="docx-btn" title="Download DOCX">
                                <span class="docx-btn-icon">⬇</span>
                            </button>
                        </div>
                    </div>
                    <div class="docx-content-area">
                        <div class="docx-loading">
                            <div class="docx-loading-spinner"></div>
                            <div>Extracting document content...</div>
                        </div>
                    </div>
                </div>
            `;

            // Request DOCX content extraction from backend
            fetch('{{ url_for("chat.get_document") }}?source=' + encodeURIComponent(source) + '&format=text')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('DOCX file not found or not accessible');
                    }
                    return response.text();
                })
                .then(textContent => {
                    const docxContentArea = contentElement.querySelector('.docx-content-area');
                    if (textContent && textContent.trim()) {
                        // Convert line breaks to HTML and preserve formatting
                        const formattedContent = textContent
                            .replace(/\n\n+/g, '</p><p>')
                            .replace(/\n/g, '<br>')
                            .replace(/^\s*/, '<p>')
                            .replace(/\s*$/, '</p>');

                        docxContentArea.innerHTML = `
                            <div class="docx-text-content">
                                ${formattedContent}
                            </div>
                        `;
                    } else {
                        docxContentArea.innerHTML = `
                            <div class="docx-error">
                                <div class="docx-error-icon">⚠️</div>
                                <div class="docx-error-text">
                                    <strong>Content extraction failed</strong><br>
                                    Unable to extract readable text from this DOCX file.
                                </div>
                            </div>
                        `;
                    }
                })
                .catch(error => {
                    const docxContentArea = contentElement.querySelector('.docx-content-area');
                    docxContentArea.innerHTML = `
                        <div class="docx-error">
                            <div class="docx-error-icon">⚠️</div>
                            <div class="docx-error-text">
                                <strong>Error loading DOCX:</strong><br>
                                ${error.message}
                            </div>
                        </div>
                    `;
                });
        }

        // DOCX utility functions
        function downloadDocx(source) {
            const link = document.createElement('a');
            link.href = '{{ url_for("chat.get_document") }}?source=' + encodeURIComponent(source);
            link.download = decodeURIComponent(source.split('/').pop());
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Simple markdown to HTML converter
        function markdownToHtml(markdown) {
            let html = markdown;

            // Headers (must come before other formatting)
            html = html.replace(/^### (.*$)/gim, '<h3>$1</h3>');
            html = html.replace(/^## (.*$)/gim, '<h2>$1</h2>');
            html = html.replace(/^# (.*$)/gim, '<h1>$1</h1>');

            // Bold and italic
            html = html.replace(/\*\*\*(.*?)\*\*\*/g, '<strong><em>$1</em></strong>');
            html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');

            // Code blocks (triple backticks)
            html = html.replace(/```(\w+)?\n([\s\S]*?)```/g, function (match, lang, code) {
                return `<pre class="code-block${lang ? ' language-' + lang : ''}"><code>${escapeHtml(code.trim())}</code></pre>`;
            });

            // Inline code
            html = html.replace(/`([^`]+)`/g, '<code class="inline-code">$1</code>');

            // Links
            html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener">$1</a>');

            // Horizontal rules
            html = html.replace(/^---+$/gm, '<hr>');

            // Unordered lists
            html = html.replace(/^\* (.+)$/gm, '<li>$1</li>');
            html = html.replace(/^\- (.+)$/gm, '<li>$1</li>');
            html = html.replace(/(<li>.*<\/li>)/gs, function (match) {
                return '<ul>' + match + '</ul>';
            });

            // Ordered lists
            html = html.replace(/^\d+\. (.+)$/gm, '<li>$1</li>');

            // Blockquotes
            html = html.replace(/^> (.+)$/gm, '<blockquote>$1</blockquote>');

            // Line breaks
            html = html.replace(/\n\n/g, '</p><p>');
            html = '<p>' + html + '</p>';

            // Clean up empty paragraphs and fix nested elements
            html = html.replace(/<p><\/p>/g, '');
            html = html.replace(/<p>(<h[1-6]>)/g, '$1');
            html = html.replace(/(<\/h[1-6]>)<\/p>/g, '$1');
            html = html.replace(/<p>(<hr>)<\/p>/g, '$1');
            html = html.replace(/<p>(<ul>)/g, '$1');
            html = html.replace(/(<\/ul>)<\/p>/g, '$1');
            html = html.replace(/<p>(<blockquote>)/g, '$1');
            html = html.replace(/(<\/blockquote>)<\/p>/g, '$1');
            html = html.replace(/<p>(<pre)/g, '$1');
            html = html.replace(/(<\/pre>)<\/p>/g, '$1');

            return html;
        }

        // Display text documents
        function displayTextDocument(source, startIndex, contentElement, allowBinaryFallback = false) {
            fetch('{{ url_for("chat.get_document") }}?source=' + encodeURIComponent(source))
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Document not found or not accessible');
                    }
                    return response.text();
                })
                .then(content => {
                    contentElement.innerHTML = '';

                    // Check if content looks like binary data
                    if (allowBinaryFallback && isBinaryContent(content)) {
                        contentElement.innerHTML = `
                            <div style="text-align: center; padding: 40px; color: #7d8590;">
                                <div style="margin-bottom: 20px;">
                                    <strong>📄 Binary Document</strong><br>
                                    <small>Source: ${escapeHtml(source)}</small>
                                </div>
                                <div style="background: #161b22; border: 1px solid #30363d; padding: 20px; border-radius: 8px; font-family: monospace;">
                                    <div>File Type: ${source.split('.').pop().toUpperCase() || 'Unknown'}</div>
                                    <div>Size: ${content.length} bytes</div>
                                    <div style="margin-top: 10px; font-size: 0.8em;">
                                        This appears to be a binary file that cannot be displayed as text.
                                    </div>
                                </div>
                            </div>
                        `;
                        return;
                    }

                    // Check if this is a markdown file
                    const isMarkdown = source.toLowerCase().endsWith('.md') || source.toLowerCase().endsWith('.markdown');

                    if (isMarkdown) {
                        // Display markdown file with proper rendering
                        const fileName = decodeURIComponent(source.split('/').pop());
                        contentElement.innerHTML = `
                            <div class="markdown-document-container">
                                <div class="markdown-header">
                                    <div class="markdown-title">
                                        <span class="markdown-icon">📝</span>
                                        <div class="markdown-info">
                                            <div class="markdown-name">${escapeHtml(fileName)}</div>
                                            <div class="markdown-source">Source: ${escapeHtml(decodeURIComponent(source))}</div>
                                        </div>
                                    </div>
                                    <div class="markdown-actions">
                                        <button onclick="downloadMarkdown('${encodeURIComponent(source)}')" class="markdown-btn" title="Download Markdown">
                                            <span class="markdown-btn-icon">⬇</span>
                                        </button>
                                        <button onclick="openMarkdownInNewTab('${encodeURIComponent(source)}')" class="markdown-btn" title="Open in New Tab">
                                            <span class="markdown-btn-icon">🔗</span>
                                        </button>
                                    </div>
                                </div>
                                <div class="markdown-content">
                                    ${markdownToHtml(content)}
                                </div>
                            </div>
                        `;
                    } else {
                        // Display as text with highlighting for non-markdown files
                        if (startIndex > 0 && content.length > startIndex) {
                            const beforeChunk = content.substring(0, startIndex);
                            const chunkContent = content.substring(startIndex, Math.min(startIndex + 500, content.length));
                            const afterChunk = content.substring(Math.min(startIndex + 500, content.length));

                            contentElement.innerHTML = escapeHtml(beforeChunk) +
                                '<span class="highlighted-chunk">' + escapeHtml(chunkContent) + '</span>' +
                                escapeHtml(afterChunk);

                            // Scroll to highlighted section
                            setTimeout(() => {
                                const highlighted = contentElement.querySelector('.highlighted-chunk');
                                if (highlighted) {
                                    highlighted.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                }
                            }, 100);
                        } else {
                            contentElement.textContent = content;
                        }
                    }
                })
                .catch(error => {
                    contentElement.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: #f85149;">
                            <strong>Error loading document:</strong><br>
                            ${error.message}
                        </div>
                    `;
                });
        }

        // Check if content appears to be binary
        function isBinaryContent(content) {
            // Check for null bytes or high ratio of non-printable characters
            if (content.includes('\0')) return true;

            let nonPrintable = 0;
            for (let i = 0; i < Math.min(content.length, 1000); i++) {
                const code = content.charCodeAt(i);
                if (code < 32 && code !== 9 && code !== 10 && code !== 13) {
                    nonPrintable++;
                }
            }

            return (nonPrintable / Math.min(content.length, 1000)) > 0.1;
        }

        // Escape HTML for safe display
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // PDF utility functions
        function downloadPdf(source) {
            const link = document.createElement('a');
            link.href = '{{ url_for("chat.get_document") }}?source=' + encodeURIComponent(source);
            link.download = decodeURIComponent(source.split('/').pop()); // Extract filename
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function openPdfInNewTab(source) {
            // Open PDF directly in new tab using our document route
            const newWindow = window.open('{{ url_for("chat.get_document") }}?source=' + encodeURIComponent(source), '_blank');
            if (!newWindow) {
                alert('Popup blocked! Please allow popups for this site to view PDF files in new tabs.');
            }
        }

        // Markdown utility functions
        function downloadMarkdown(source) {
            const link = document.createElement('a');
            link.href = '{{ url_for("chat.get_document") }}?source=' + encodeURIComponent(source);
            link.download = decodeURIComponent(source.split('/').pop());
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function openMarkdownInNewTab(source) {
            // Fetch the markdown content and display rendered HTML in new tab
            fetch('{{ url_for("chat.get_document") }}?source=' + encodeURIComponent(source))
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Markdown file not accessible');
                    }
                    return response.text();
                })
                .then(markdownContent => {
                    const newWindow = window.open('', '_blank');
                    if (newWindow) {
                        const fileName = decodeURIComponent(source.split('/').pop());
                        const renderedHtml = markdownToHtml(markdownContent);

                        newWindow.document.write(`
                            <!DOCTYPE html>
                            <html>
                            <head>
                                <title>${fileName}</title>
                                <meta charset="utf-8">
                                <style>
                                    body { 
                                        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                                        max-width: 800px;
                                        margin: 0 auto;
                                        padding: 20px;
                                        background: #0d1117; 
                                        color: #e6edf3;
                                        line-height: 1.6;
                                    }
                                    .header {
                                        border-bottom: 1px solid #21262d;
                                        padding-bottom: 15px;
                                        margin-bottom: 30px;
                                    }
                                    .header h1 { 
                                        color: #58a6ff; 
                                        font-size: 1.8em;
                                        margin: 0 0 5px 0;
                                    }
                                    .header .info { 
                                        color: #7d8590; 
                                        font-size: 0.9em;
                                    }
                                    h1, h2, h3, h4, h5, h6 { color: #58a6ff; margin-top: 2em; margin-bottom: 0.5em; }
                                    h1 { font-size: 2em; border-bottom: 1px solid #21262d; padding-bottom: 0.3em; }
                                    h2 { font-size: 1.5em; border-bottom: 1px solid #21262d; padding-bottom: 0.3em; }
                                    h3 { font-size: 1.25em; }
                                    p { margin-bottom: 1em; }
                                    a { color: #58a6ff; text-decoration: none; }
                                    a:hover { text-decoration: underline; }
                                    code.inline-code { 
                                        background: #161b22; 
                                        color: #f0883e;
                                        padding: 2px 6px; 
                                        border-radius: 3px; 
                                        font-family: 'SF Mono', Consolas, monospace;
                                        font-size: 0.9em;
                                    }
                                    pre.code-block { 
                                        background: #161b22; 
                                        border: 1px solid #30363d;
                                        border-radius: 6px;
                                        padding: 16px; 
                                        overflow: auto;
                                        margin: 1em 0;
                                    }
                                    pre.code-block code {
                                        color: #e6edf3;
                                        font-family: 'SF Mono', Consolas, monospace;
                                        font-size: 0.9em;
                                    }
                                    ul, ol { padding-left: 2em; margin: 1em 0; }
                                    li { margin: 0.25em 0; }
                                    blockquote { 
                                        border-left: 4px solid #30363d; 
                                        padding-left: 16px; 
                                        margin: 1em 0;
                                        color: #7d8590;
                                        background: rgba(22, 27, 34, 0.5);
                                        border-radius: 0 6px 6px 0;
                                        padding: 8px 16px;
                                    }
                                    hr { 
                                        border: none; 
                                        border-top: 1px solid #21262d; 
                                        margin: 2em 0; 
                                    }
                                    strong { color: #f0f6fc; }
                                    em { color: #f0f6fc; font-style: italic; }
                                </style>
                            </head>
                            <body>
                                <div class="header">
                                    <h1>📝 ${fileName}</h1>
                                    <div class="info">Source: ${decodeURIComponent(source)}</div>
                                </div>
                                <div class="content">
                                    ${renderedHtml}
                                </div>
                            </body>
                            </html>
                        `);
                        newWindow.document.close();
                    } else {
                        alert('Popup blocked! Please allow popups for this site to view markdown files in new tabs.');
                    }
                })
                .catch(error => {
                    alert('Error opening markdown file: ' + error.message);
                });
        }

        // Handle escape key to close document viewer
        document.addEventListener('keydown', function (e) {
            if (e.key === 'Escape') {
                closeDocumentViewer();
            }
        });

        // Load source context and re-run query
        async function loadSourceContext(button) {
            const sourcePath = button.getAttribute('data-source-path');

            // Disable button and show loading
            const originalText = button.innerHTML;
            button.disabled = true;
            button.innerHTML = '<span class="load-icon">⏳</span> Loading...';

            try {
                const response = await fetch('/load_source', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        source_path: sourcePath
                    })
                });

                const result = await response.json();

                if (!response.ok) {
                    throw new Error(result.error || 'Failed to load source');
                }

                // Store the loaded context in a hidden form field
                let contextInput = document.getElementById('loaded_context');
                if (!contextInput) {
                    contextInput = document.createElement('input');
                    contextInput.type = 'hidden';
                    contextInput.id = 'loaded_context';
                    contextInput.name = 'loaded_context';
                    document.getElementById('chat-form').appendChild(contextInput);
                }

                // Store metadata about the loaded source
                let sourceMetaInput = document.getElementById('loaded_source_meta');
                if (!sourceMetaInput) {
                    sourceMetaInput = document.createElement('input');
                    sourceMetaInput.type = 'hidden';
                    sourceMetaInput.id = 'loaded_source_meta';
                    sourceMetaInput.name = 'loaded_source_meta';
                    document.getElementById('chat-form').appendChild(sourceMetaInput);
                }

                contextInput.value = result.enhanced_context;
                sourceMetaInput.value = JSON.stringify({
                    source_path: result.source_path,
                    context_type: result.context_type
                });

                // Update button to show success
                button.innerHTML = '<span class="load-icon">✅</span> Loaded';
                button.style.backgroundColor = '#28a745';
                button.style.color = 'white';

                // Show a temporary notification
                showNotification(`Loaded context from ${sourcePath.split('/').pop()}. It will be included with your next question.`, 'success');

            } catch (error) {
                console.error('Error loading source:', error);
                showNotification('Error loading source: ' + error.message, 'error');

                // Restore button
                button.disabled = false;
                button.innerHTML = originalText;
            }
        }

        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.textContent = message;
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 12px 20px;
                border-radius: 6px;
                color: white;
                font-weight: 500;
                z-index: 1000;
                max-width: 400px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                ${type === 'success' ? 'background-color: #28a745;' : ''}
                ${type === 'error' ? 'background-color: #dc3545;' : ''}
                ${type === 'info' ? 'background-color: #17a2b8;' : ''}
            `;

            document.body.appendChild(notification);

            // Remove after 5 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 5000);
        }
    </script>
</body>

</html>