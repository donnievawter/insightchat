<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>InsightChat - AI Chat with RAG</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>

<body>
    <div class="chat-container">
        <div class="chat-header">
            <h1>InsightChat</h1>
            <form method="POST" action="{{ url_for('chat.reset') }}" style="display: inline;">
                <button type="submit" class="reset-btn">Reset Chat</button>
            </form>
        </div>

        <div class="chat-settings">
            <div class="settings-row">
                <label for="model">Model:</label>
                <select name="model" id="model" form="chat-form">
                    {% for model_info in available_models %}
                    <option value="{{ model_info.name }}" {{ 'selected' if model==model_info.name else '' }}>
                        {{ model_info.name }}
                        {% if model_info.parameter_size %}({{ model_info.parameter_size }}){% endif %}
                    </option>
                    {% endfor %}
                </select>

                <label for="use_repo_docs">
                    <input type="checkbox" name="use_repo_docs" id="use_repo_docs" form="chat-form" {{ 'checked' if
                        use_repo_docs else '' }}>
                    Use RAG Context
                </label>
            </div>
        </div>

        {% if error %}
        <div class="error-message">{{ error }}</div>
        {% endif %}

        <div class="chat-messages" id="chat-messages">
            {% for message in message_history %}
            <div class="message {{ message.role }}">
                <div class="message-header">
                    <span class="message-role">{{ message.role.title() }}</span>
                    {% if message.role == 'assistant' and message.get('rag_chunks') %}
                    <button class="toggle-chunks-btn" onclick="toggleChunks('{{ loop.index }}')">
                        <span id="chunks-icon-{{ loop.index }}">üìÑ</span>
                        <span id="chunks-text-{{ loop.index }}">Show Sources ({{ message.rag_chunks|length }})</span>
                    </button>
                    {% endif %}

                    {% if message.role == 'assistant' and message.get('hybrid_analysis') %}
                    <div class="hybrid-indicator">
                        <span class="hybrid-icon">üîç</span>
                        <span class="hybrid-text">Full Document Analysis</span>
                        <span class="hybrid-count">({{ message.analyzed_documents|length }} docs)</span>
                    </div>
                    {% endif %}
                </div>
                <div class="message-content">{{ message.content | safe }}</div>

                {% if message.role == 'assistant' and message.get('rag_chunks') %}
                <div class="rag-chunks" id="chunks-{{ loop.index }}" style="display: none;">
                    <div class="chunks-header">
                        <h4>Retrieved Context Sources</h4>
                    </div>
                    {% set outer_loop = loop %}
                    {% for chunk in message.rag_chunks %}
                    <div class="chunk-item">
                        <div class="chunk-header">
                            <span class="chunk-source">{{ chunk.metadata.get('source', 'Unknown Source') }}</span>
                            {% if chunk.metadata.get('page') %}
                            <span class="chunk-page">Page {{ chunk.metadata.page }}</span>
                            {% endif %}
                            <button class="view-doc-btn" data-source="{{ chunk.metadata.get('source', '') }}"
                                data-start-index="{{ chunk.get('start_index', 0) }}">
                                View Document
                            </button>
                        </div>
                        <div class="chunk-content">
                            <p>{{ chunk.content[:200] }}{% if chunk.content|length > 200 %}...{% endif %}</p>
                        </div>
                        <div class="chunk-actions">
                            <button class="expand-chunk-btn"
                                onclick="toggleChunkExpansion('msg{{ outer_loop.index }}_chunk{{ loop.index0 }}')">
                                <span id="chunk-expand-msg{{ outer_loop.index }}_chunk{{ loop.index0 }}">Show
                                    More</span>
                            </button>
                            <div class="chunk-full-content"
                                id="chunk-full-msg{{ outer_loop.index }}_chunk{{ loop.index0 }}" style="display: none;">
                                <p>{{ chunk.content }}</p>
                            </div>
                        </div>
                    </div>
                    {% endfor %}
                </div>
                {% endif %}
            </div>
            {% endfor %}
        </div>

        <form id="chat-form" method="POST" action="{{ url_for('chat.chat') }}">
            <div class="input-row">
                <input type="text" name="prompt" placeholder="Type your message..." required>
                <button type="submit">Send</button>
            </div>
        </form>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // Auto-scroll to bottom of messages
            const chatMessages = document.getElementById('chat-messages');
            if (chatMessages) {
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }

            // Focus on input field
            const promptInput = document.querySelector('input[name="prompt"]');
            if (promptInput) {
                promptInput.focus();
            }

            // Handle form submission to disable/enable send button
            const chatForm = document.getElementById('chat-form');
            const sendButton = chatForm ? chatForm.querySelector('button[type="submit"]') : null;

            if (chatForm && sendButton) {
                const originalButtonText = sendButton.textContent;

                chatForm.addEventListener('submit', function (e) {
                    const message = promptInput.value.trim();
                    if (!message) {
                        e.preventDefault();
                        return;
                    }

                    // Disable button and show loading state
                    sendButton.disabled = true;
                    sendButton.textContent = 'Sending...';
                });
            }

            // Handle view document buttons
            document.addEventListener('click', function (e) {
                if (e.target.classList.contains('view-doc-btn')) {
                    const source = e.target.getAttribute('data-source');
                    const startIndex = parseInt(e.target.getAttribute('data-start-index') || '0');
                    viewDocument(source, startIndex);
                }
            });
        });

        // Toggle chunks display
        function toggleChunks(messageIndex) {
            const chunksDiv = document.getElementById('chunks-' + messageIndex);
            const icon = document.getElementById('chunks-icon-' + messageIndex);
            const text = document.getElementById('chunks-text-' + messageIndex);

            if (chunksDiv.style.display === 'none') {
                chunksDiv.style.display = 'block';
                icon.textContent = 'üìÇ';
                text.textContent = text.textContent.replace('Show', 'Hide');
            } else {
                chunksDiv.style.display = 'none';
                icon.textContent = 'üìÑ';
                text.textContent = text.textContent.replace('Hide', 'Show');
            }
        }

        // Toggle individual chunk expansion
        function toggleChunkExpansion(chunkIndex) {
            const fullContent = document.getElementById('chunk-full-' + chunkIndex);
            const expandBtn = document.getElementById('chunk-expand-' + chunkIndex);

            if (fullContent && expandBtn) {
                if (fullContent.style.display === 'none') {
                    fullContent.style.display = 'block';
                    expandBtn.textContent = 'Show Less';
                } else {
                    fullContent.style.display = 'none';
                    expandBtn.textContent = 'Show More';
                }
            }
        }

        // View document in modal
        function viewDocument(source, startIndex = 0) {
            // Create modal overlay
            const overlay = document.createElement('div');
            overlay.className = 'document-viewer-overlay';
            overlay.onclick = function (e) {
                if (e.target === overlay) {
                    closeDocumentViewer();
                }
            };

            // Create document viewer
            const viewer = document.createElement('div');
            viewer.className = 'document-viewer';

            // Create header
            const header = document.createElement('div');
            header.className = 'document-viewer-header';
            header.innerHTML = `
                <h3>${source}</h3>
                <button class="document-viewer-close" onclick="closeDocumentViewer()">Close</button>
            `;

            // Create content area
            const content = document.createElement('div');
            content.className = 'document-viewer-content';
            content.innerHTML = '<div style="text-align: center; padding: 40px; color: #7d8590;">Loading document...</div>';

            viewer.appendChild(header);
            viewer.appendChild(content);
            overlay.appendChild(viewer);
            document.body.appendChild(overlay);

            // Fetch document content
            fetchDocumentContent(source, startIndex, content);
        }

        // Close document viewer
        function closeDocumentViewer() {
            const overlay = document.querySelector('.document-viewer-overlay');
            if (overlay) {
                overlay.remove();
            }
        }

        // Fetch and display document content
        function fetchDocumentContent(source, startIndex, contentElement) {
            // Determine file type from extension
            const fileExtension = source.split('.').pop().toLowerCase();
            const imageExtensions = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'svg', 'bmp'];
            const textExtensions = ['txt', 'md', 'py', 'js', 'html', 'css', 'json', 'xml', 'yaml', 'yml', 'sh', 'conf', 'log'];
            const pdfExtensions = ['pdf'];
            const csvExtensions = ['csv', 'tsv'];

            if (imageExtensions.includes(fileExtension)) {
                // Display image
                displayImageDocument(source, contentElement);
            } else if (pdfExtensions.includes(fileExtension)) {
                // Display PDF
                displayPdfDocument(source, contentElement);
            } else if (csvExtensions.includes(fileExtension)) {
                // Display CSV as table
                displayCsvDocument(source, contentElement);
            } else if (textExtensions.includes(fileExtension)) {
                // Display as text
                displayTextDocument(source, startIndex, contentElement);
            } else {
                // Try to display as text first, fallback to binary info
                displayTextDocument(source, startIndex, contentElement, true);
            }
        }

        // Display image documents
        function displayImageDocument(source, contentElement) {
            contentElement.innerHTML = `
                <div style="text-align: center; padding: 20px;">
                    <div style="margin-bottom: 20px; color: #58a6ff;">
                        <strong>üì∑ Image Document</strong><br>
                        <small>Source: ${escapeHtml(source)}</small>
                    </div>
                    <div style="max-width: 100%; overflow: auto;">
                        <img src="{{ url_for('chat.get_document') }}?source=${encodeURIComponent(source)}" 
                             alt="${escapeHtml(source)}" 
                             style="max-width: 100%; height: auto; border: 1px solid #30363d; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.3);"
                             onload="this.style.display='block'" 
                             onerror="this.style.display='none'; this.nextElementSibling.style.display='block'">
                        <div style="display: none; padding: 20px; background: #2d1b20; border: 1px solid #da3633; border-radius: 8px; color: #f97583;">
                            <strong>Error loading image</strong><br>
                            The image could not be displayed. It may be corrupted or in an unsupported format.
                        </div>
                    </div>
                    <div style="margin-top: 20px; font-size: 0.9em; color: #7d8590;">
                        This image was referenced in the RAG context. 
                        <br>For text content, check if there are associated description files.
                    </div>
                </div>
            `;
        }

        // Display PDF documents
        function displayPdfDocument(source, contentElement) {
            contentElement.innerHTML = `
                <div class="pdf-document-container">
                    <div class="pdf-header">
                        <div class="pdf-title">
                            <span class="pdf-icon">üìÑ</span>
                            <div class="pdf-info">
                                <div class="pdf-name">${escapeHtml(decodeURIComponent(source.split('/').pop()))}</div>
                                <div class="pdf-source">Source: ${escapeHtml(decodeURIComponent(source))}</div>
                            </div>
                        </div>
                        <div class="pdf-actions">
                            <button onclick="downloadPdf('${encodeURIComponent(source)}')" class="pdf-btn pdf-download-btn" title="Download PDF">
                                <span class="pdf-btn-icon">‚¨á</span>
                            </button>
                            <button onclick="openPdfInNewTab('${encodeURIComponent(source)}')" class="pdf-btn pdf-newtab-btn" title="Open in New Tab">
                                <span class="pdf-btn-icon">‚Üó</span>
                            </button>
                        </div>
                    </div>
                    <div class="pdf-viewer-frame">
                        <iframe id="pdf-viewer-${Date.now()}" 
                                src="{{ url_for('chat.get_document') }}?source=${encodeURIComponent(source)}" 
                                class="pdf-iframe"
                                onload="this.style.display='block'; this.nextElementSibling.style.display='none';"
                                onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                        </iframe>
                        <div class="pdf-error-fallback" style="display: none;">
                            <div class="pdf-error-content">
                                <div class="pdf-error-icon">‚ö†Ô∏è</div>
                                <div class="pdf-error-text">
                                    <strong>PDF Preview Unavailable</strong><br>
                                    <span>Your browser doesn't support inline PDF viewing</span>
                                </div>
                                <button onclick="downloadPdf('${encodeURIComponent(source)}')" class="pdf-error-btn">
                                    Download PDF
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        // Display CSV documents as tables
        function displayCsvDocument(source, contentElement) {
            contentElement.innerHTML = `
                <div class="csv-document-container">
                    <div class="csv-header">
                        <div class="csv-title">
                            <span class="csv-icon">üìä</span>
                            <div class="csv-info">
                                <div class="csv-name">${escapeHtml(decodeURIComponent(source.split('/').pop()))}</div>
                                <div class="csv-source">Source: ${escapeHtml(decodeURIComponent(source))}</div>
                            </div>
                        </div>
                        <div class="csv-actions">
                            <button onclick="downloadCsv('${encodeURIComponent(source)}')" class="csv-btn csv-download-btn" title="Download CSV">
                                <span class="csv-btn-icon">‚¨á</span>
                            </button>
                            <button onclick="openCsvInNewTab('${encodeURIComponent(source)}')" class="csv-btn csv-newtab-btn" title="Open Raw CSV">
                                <span class="csv-btn-icon">‚Üó</span>
                            </button>
                        </div>
                    </div>
                    <div class="csv-content-area">
                        <div class="csv-loading">Loading CSV data...</div>
                    </div>
                </div>
            `;

            // Fetch and parse CSV data
            fetch('{{ url_for("chat.get_document") }}?source=' + encodeURIComponent(source))
                .then(response => {
                    if (!response.ok) {
                        throw new Error('CSV file not found or not accessible');
                    }
                    return response.text();
                })
                .then(csvData => {
                    const csvContentArea = contentElement.querySelector('.csv-content-area');
                    const tableHtml = parseCsvToTable(csvData, source);
                    csvContentArea.innerHTML = tableHtml;
                })
                .catch(error => {
                    const csvContentArea = contentElement.querySelector('.csv-content-area');
                    csvContentArea.innerHTML = `
                        <div class="csv-error">
                            <div class="csv-error-icon">‚ö†Ô∏è</div>
                            <div class="csv-error-text">
                                <strong>Error loading CSV:</strong><br>
                                ${error.message}
                            </div>
                        </div>
                    `;
                });
        }

        // Parse CSV data and convert to HTML table
        function parseCsvToTable(csvData, source) {
            const lines = csvData.trim().split('\n');
            if (lines.length === 0) {
                return '<div class="csv-error">Empty CSV file</div>';
            }

            // Detect delimiter - check for common separators
            const firstLine = lines[0];
            let delimiter = ',';
            if (source.toLowerCase().endsWith('.tsv') || firstLine.includes('\t')) {
                delimiter = '\t';
            } else if (firstLine.split(';').length > firstLine.split(',').length) {
                delimiter = ';';
            }

            // Parse CSV rows
            const rows = lines.map(line => parseCsvLine(line, delimiter));

            if (rows.length === 0) {
                return '<div class="csv-error">No data found in CSV</div>';
            }

            // Build HTML table
            let tableHtml = `
                <div class="csv-info-bar">
                    <span class="csv-stats">${rows.length - 1} rows √ó ${rows[0]?.length || 0} columns</span>
                    <span class="csv-delimiter">Delimiter: ${delimiter === '\t' ? 'Tab' : delimiter}</span>
                </div>
                <div class="csv-table-wrapper">
                    <table class="csv-table">
            `;

            // Add header row (assume first row is headers)
            if (rows[0]) {
                tableHtml += '<thead><tr>';
                rows[0].forEach(cell => {
                    tableHtml += `<th>${escapeHtml(cell)}</th>`;
                });
                tableHtml += '</tr></thead>';
            }

            // Add data rows
            tableHtml += '<tbody>';
            const dataRows = rows.slice(1); // Skip header row
            const maxRows = 1000; // Limit for performance
            const displayRows = dataRows.slice(0, maxRows);

            displayRows.forEach(row => {
                tableHtml += '<tr>';
                row.forEach(cell => {
                    tableHtml += `<td>${escapeHtml(cell)}</td>`;
                });
                tableHtml += '</tr>';
            });

            if (dataRows.length > maxRows) {
                tableHtml += `
                    <tr class="csv-truncated-notice">
                        <td colspan="${rows[0]?.length || 1}">
                            <em>... ${dataRows.length - maxRows} more rows (showing first ${maxRows} rows)</em>
                        </td>
                    </tr>
                `;
            }

            tableHtml += '</tbody></table></div>';
            return tableHtml;
        }

        // Simple CSV line parser (handles quoted fields)
        function parseCsvLine(line, delimiter = ',') {
            const result = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];

                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === delimiter && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }

            result.push(current.trim());
            return result;
        }

        // CSV utility functions
        function downloadCsv(source) {
            const link = document.createElement('a');
            link.href = '{{ url_for("chat.get_document") }}?source=' + encodeURIComponent(source);
            link.download = decodeURIComponent(source.split('/').pop());
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function openCsvInNewTab(source) {
            // Fetch the CSV content and display in new tab
            fetch('{{ url_for("chat.get_document") }}?source=' + encodeURIComponent(source))
                .then(response => {
                    if (!response.ok) {
                        throw new Error('CSV file not accessible');
                    }
                    return response.text();
                })
                .then(csvContent => {
                    // Create a new window and write HTML content to display the CSV
                    const newWindow = window.open('', '_blank');
                    if (newWindow) {
                        const fileName = decodeURIComponent(source.split('/').pop());
                        const tableHtml = parseCsvToTable(csvContent, source);

                        newWindow.document.write(`
                            <!DOCTYPE html>
                            <html>
                            <head>
                                <title>${fileName}</title>
                                <style>
                                    body { 
                                        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                                        margin: 20px; 
                                        background: #0d1117; 
                                        color: #e6edf3;
                                    }
                                    h1 { 
                                        color: #58a6ff; 
                                        font-size: 1.5em;
                                        margin-bottom: 10px;
                                    }
                                    .info { 
                                        color: #7d8590; 
                                        margin-bottom: 20px; 
                                        font-size: 0.9em;
                                    }
                                    .csv-table-wrapper {
                                        border: 1px solid #21262d;
                                        border-radius: 6px;
                                        overflow: auto;
                                        max-height: 80vh;
                                    }
                                    .csv-table {
                                        width: 100%;
                                        border-collapse: collapse;
                                        font-size: 0.85em;
                                        background: #0d1117;
                                    }
                                    .csv-table th {
                                        background: #161b22;
                                        color: #58a6ff;
                                        font-weight: 600;
                                        padding: 8px 12px;
                                        text-align: left;
                                        border-bottom: 2px solid #30363d;
                                        border-right: 1px solid #21262d;
                                        position: sticky;
                                        top: 0;
                                        z-index: 100;
                                        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                                    }
                                    .csv-table th:last-child { border-right: none; }
                                    .csv-table td {
                                        padding: 6px 12px;
                                        border-bottom: 1px solid #21262d;
                                        border-right: 1px solid #21262d;
                                        color: #e6edf3;
                                        white-space: nowrap;
                                        overflow: hidden;
                                        text-overflow: ellipsis;
                                        max-width: 200px;
                                    }
                                    .csv-table td:last-child { border-right: none; }
                                    .csv-table tbody tr:hover { background: #161b22; }
                                    .csv-table tbody tr:nth-child(even) { background: rgba(22, 27, 34, 0.5); }
                                    .csv-table tbody tr:nth-child(even):hover { background: #161b22; }
                                    .csv-info-bar {
                                        display: flex;
                                        justify-content: space-between;
                                        padding: 8px 12px;
                                        background: #161b22;
                                        border-bottom: 1px solid #21262d;
                                        font-size: 0.8em;
                                        color: #7d8590;
                                    }
                                </style>
                            </head>
                            <body>
                                <h1>üìä ${fileName}</h1>
                                <div class="info">Source: ${decodeURIComponent(source)}</div>
                                ${tableHtml}
                            </body>
                            </html>
                        `);
                        newWindow.document.close();
                    } else {
                        alert('Popup blocked! Please allow popups for this site to view CSV files in new tabs.');
                    }
                })
                .catch(error => {
                    alert('Error opening CSV file: ' + error.message);
                });
        }

        // Display text documents
        function displayTextDocument(source, startIndex, contentElement, allowBinaryFallback = false) {
            fetch('{{ url_for("chat.get_document") }}?source=' + encodeURIComponent(source))
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Document not found or not accessible');
                    }
                    return response.text();
                })
                .then(content => {
                    contentElement.innerHTML = '';

                    // Check if content looks like binary data
                    if (allowBinaryFallback && isBinaryContent(content)) {
                        contentElement.innerHTML = `
                            <div style="text-align: center; padding: 40px; color: #7d8590;">
                                <div style="margin-bottom: 20px;">
                                    <strong>üìÑ Binary Document</strong><br>
                                    <small>Source: ${escapeHtml(source)}</small>
                                </div>
                                <div style="background: #161b22; border: 1px solid #30363d; padding: 20px; border-radius: 8px; font-family: monospace;">
                                    <div>File Type: ${source.split('.').pop().toUpperCase() || 'Unknown'}</div>
                                    <div>Size: ${content.length} bytes</div>
                                    <div style="margin-top: 10px; font-size: 0.8em;">
                                        This appears to be a binary file that cannot be displayed as text.
                                    </div>
                                </div>
                            </div>
                        `;
                        return;
                    }

                    // Display as text with highlighting
                    if (startIndex > 0 && content.length > startIndex) {
                        const beforeChunk = content.substring(0, startIndex);
                        const chunkContent = content.substring(startIndex, Math.min(startIndex + 500, content.length));
                        const afterChunk = content.substring(Math.min(startIndex + 500, content.length));

                        contentElement.innerHTML = escapeHtml(beforeChunk) +
                            '<span class="highlighted-chunk">' + escapeHtml(chunkContent) + '</span>' +
                            escapeHtml(afterChunk);

                        // Scroll to highlighted section
                        setTimeout(() => {
                            const highlighted = contentElement.querySelector('.highlighted-chunk');
                            if (highlighted) {
                                highlighted.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }
                        }, 100);
                    } else {
                        contentElement.textContent = content;
                    }
                })
                .catch(error => {
                    contentElement.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: #f85149;">
                            <strong>Error loading document:</strong><br>
                            ${error.message}
                        </div>
                    `;
                });
        }

        // Check if content appears to be binary
        function isBinaryContent(content) {
            // Check for null bytes or high ratio of non-printable characters
            if (content.includes('\0')) return true;

            let nonPrintable = 0;
            for (let i = 0; i < Math.min(content.length, 1000); i++) {
                const code = content.charCodeAt(i);
                if (code < 32 && code !== 9 && code !== 10 && code !== 13) {
                    nonPrintable++;
                }
            }

            return (nonPrintable / Math.min(content.length, 1000)) > 0.1;
        }

        // Escape HTML for safe display
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // PDF utility functions
        function downloadPdf(source) {
            const link = document.createElement('a');
            link.href = '{{ url_for("chat.get_document") }}?source=' + encodeURIComponent(source);
            link.download = decodeURIComponent(source.split('/').pop()); // Extract filename
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function openPdfInNewTab(source) {
            // Open PDF directly in new tab using our document route
            const newWindow = window.open('{{ url_for("chat.get_document") }}?source=' + encodeURIComponent(source), '_blank');
            if (!newWindow) {
                alert('Popup blocked! Please allow popups for this site to view PDF files in new tabs.');
            }
        }

        // Handle escape key to close document viewer
        document.addEventListener('keydown', function (e) {
            if (e.key === 'Escape') {
                closeDocumentViewer();
            }
        });
    </script>
</body>

</html>